import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** An ISO 8601-encoded datetime */
  ISO8601DateTime: any;
};

/** Autogenerated input type of CreateEvent */
export type CreateEventInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  eventInput: EventInput;
};

/** Autogenerated return type of CreateEvent */
export type CreateEventPayload = {
  __typename?: 'CreateEventPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  event?: Maybe<Event>;
};

/** Autogenerated input type of DeleteEvent */
export type DeleteEventInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteEvent */
export type DeleteEventPayload = {
  __typename?: 'DeleteEventPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  success?: Maybe<Scalars['Boolean']>;
};

/** Autogenerated input type of DeletePlayer */
export type DeletePlayerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated return type of DeletePlayer */
export type DeletePlayerPayload = {
  __typename?: 'DeletePlayerPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  success?: Maybe<Scalars['Boolean']>;
};

/** Autogenerated input type of DeleteRound */
export type DeleteRoundInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteRound */
export type DeleteRoundPayload = {
  __typename?: 'DeleteRoundPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  success?: Maybe<Scalars['Boolean']>;
};

export type Error = {
  __typename?: 'Error';
  attribute: Scalars['String'];
  message: Scalars['String'];
};


export type ErrorMessageArgs = {
  full?: InputMaybe<Scalars['Boolean']>;
};

export type Event = {
  __typename?: 'Event';
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  name: Scalars['String'];
  players: PlayerConnection;
  rounds: Array<Round>;
};


export type EventPlayersArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  deleted?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for Event. */
export type EventConnection = {
  __typename?: 'EventConnection';
  /** A list of edges. */
  edges: Array<EventEdge>;
  /** A list of nodes. */
  nodes: Array<Event>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type EventEdge = {
  __typename?: 'EventEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Event>;
};

export type EventInput = {
  name?: InputMaybe<Scalars['String']>;
};

export type Match = {
  __typename?: 'Match';
  draw: Scalars['Boolean'];
  id: Scalars['ID'];
  player1: Player;
  player1Id: Scalars['ID'];
  player2?: Maybe<Player>;
  player2Id?: Maybe<Scalars['ID']>;
  roundId: Scalars['ID'];
  winnerId?: Maybe<Scalars['ID']>;
};

export type MatchInput = {
  draw?: InputMaybe<Scalars['Boolean']>;
  winnerId?: InputMaybe<Scalars['ID']>;
};

export type Mutation = {
  __typename?: 'Mutation';
  /** Creates a new Event */
  eventCreate?: Maybe<CreateEventPayload>;
  /** Deletes an existing Event by ID */
  eventDelete?: Maybe<DeleteEventPayload>;
  /** Updates an existing Event by ID */
  eventUpdate?: Maybe<UpdateEventPayload>;
  /** Updates an existing Match by ID */
  matchUpdate?: Maybe<UpdateMatchPayload>;
  /** Creates a new Player */
  playerCreate?: Maybe<PlayerCreatePayload>;
  /** Deletes an existing Player by ID */
  playerDelete?: Maybe<DeletePlayerPayload>;
  /** Updates an existing Player by ID */
  playerUpdate?: Maybe<UpdatePlayerPayload>;
  /** Create a new Round */
  roundCreate?: Maybe<RoundCreatePayload>;
  /** Deletes an existing Round by ID */
  roundDelete?: Maybe<DeleteRoundPayload>;
  /** Updates the Match pairings for a Round */
  roundUpdatePairings?: Maybe<RoundUpdatePairingsPayload>;
};


export type MutationEventCreateArgs = {
  input: CreateEventInput;
};


export type MutationEventDeleteArgs = {
  input: DeleteEventInput;
};


export type MutationEventUpdateArgs = {
  input: UpdateEventInput;
};


export type MutationMatchUpdateArgs = {
  input: UpdateMatchInput;
};


export type MutationPlayerCreateArgs = {
  input: PlayerCreateInput;
};


export type MutationPlayerDeleteArgs = {
  input: DeletePlayerInput;
};


export type MutationPlayerUpdateArgs = {
  input: UpdatePlayerInput;
};


export type MutationRoundCreateArgs = {
  input: RoundCreateInput;
};


export type MutationRoundDeleteArgs = {
  input: DeleteRoundInput;
};


export type MutationRoundUpdatePairingsArgs = {
  input: RoundUpdatePairingsInput;
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']>;
};

export type Player = {
  __typename?: 'Player';
  deleted: Scalars['Boolean'];
  deletedAt?: Maybe<Scalars['ISO8601DateTime']>;
  drawsCount: Scalars['Int'];
  dropped: Scalars['Boolean'];
  eventId: Scalars['ID'];
  id: Scalars['ID'];
  lossesCount: Scalars['Int'];
  name: Scalars['String'];
  paid: Scalars['Boolean'];
  score: Scalars['Int'];
  winsCount: Scalars['Int'];
};

/** The connection type for Player. */
export type PlayerConnection = {
  __typename?: 'PlayerConnection';
  /** A list of edges. */
  edges: Array<PlayerEdge>;
  /** A list of nodes. */
  nodes: Array<Player>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** Autogenerated input type of PlayerCreate */
export type PlayerCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the Event to add the Player to */
  eventId: Scalars['ID'];
  playerInput: PlayerInput;
};

/** Autogenerated return type of PlayerCreate */
export type PlayerCreatePayload = {
  __typename?: 'PlayerCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  /** The Event that the Player was added to */
  event?: Maybe<Event>;
  player?: Maybe<Player>;
};

/** An edge in a connection. */
export type PlayerEdge = {
  __typename?: 'PlayerEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Player>;
};

export type PlayerInput = {
  dropped?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  paid?: InputMaybe<Scalars['Boolean']>;
};

export type Query = {
  __typename?: 'Query';
  /** Finds a Event by ID */
  event: Event;
  /** Finds a list of Event objects */
  events: EventConnection;
  /** Finds a Match by ID */
  match: Match;
  /** Finds a Player by ID */
  player: Player;
  /** Finds a Round by ID */
  round: Round;
  /** Generates a possible list of pairings for a round. */
  roundProposePairings: Array<Array<Maybe<Player>>>;
};


export type QueryEventArgs = {
  id: Scalars['ID'];
};


export type QueryEventsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueryMatchArgs = {
  id: Scalars['ID'];
};


export type QueryPlayerArgs = {
  id: Scalars['ID'];
};


export type QueryRoundArgs = {
  id: Scalars['ID'];
};


export type QueryRoundProposePairingsArgs = {
  excludePlayerIds?: InputMaybe<Array<Scalars['ID']>>;
  roundId: Scalars['ID'];
};

export type Round = {
  __typename?: 'Round';
  eventId: Scalars['ID'];
  id: Scalars['ID'];
  matches: Array<Match>;
  number: Scalars['Int'];
};

/** Autogenerated input type of RoundCreate */
export type RoundCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the Event to add the Round to */
  eventId: Scalars['ID'];
};

/** Autogenerated return type of RoundCreate */
export type RoundCreatePayload = {
  __typename?: 'RoundCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  /** The Event that the Round was added to */
  event?: Maybe<Event>;
  /** The Round that was created */
  round?: Maybe<Round>;
};

/** Autogenerated input type of RoundUpdatePairings */
export type RoundUpdatePairingsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The IDs of the Players to pair */
  pairings: Array<Array<InputMaybe<Scalars['ID']>>>;
  /** The ID of the Round to update */
  roundId: Scalars['ID'];
};

/** Autogenerated return type of RoundUpdatePairings */
export type RoundUpdatePairingsPayload = {
  __typename?: 'RoundUpdatePairingsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  round?: Maybe<Round>;
};

/** Autogenerated input type of UpdateEvent */
export type UpdateEventInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  eventInput: EventInput;
  id: Scalars['ID'];
};

/** Autogenerated return type of UpdateEvent */
export type UpdateEventPayload = {
  __typename?: 'UpdateEventPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  event?: Maybe<Event>;
};

/** Autogenerated input type of UpdateMatch */
export type UpdateMatchInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  matchInput: MatchInput;
};

/** Autogenerated return type of UpdateMatch */
export type UpdateMatchPayload = {
  __typename?: 'UpdateMatchPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  match?: Maybe<Match>;
};

/** Autogenerated input type of UpdatePlayer */
export type UpdatePlayerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  playerInput: PlayerInput;
};

/** Autogenerated return type of UpdatePlayer */
export type UpdatePlayerPayload = {
  __typename?: 'UpdatePlayerPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  player?: Maybe<Player>;
};

export type CreateEventMutationVariables = Exact<{
  input: EventInput;
}>;


export type CreateEventMutation = { __typename?: 'Mutation', eventCreate?: { __typename?: 'CreateEventPayload', event?: { __typename?: 'Event', id: string, name: string } | null, errors?: Array<{ __typename?: 'Error', attribute: string, message: string }> | null } | null };

export type CreatePlayerMutationVariables = Exact<{
  eventID: Scalars['ID'];
  input: PlayerInput;
}>;


export type CreatePlayerMutation = { __typename?: 'Mutation', playerCreate?: { __typename?: 'PlayerCreatePayload', player?: { __typename?: 'Player', id: string } | null, errors?: Array<{ __typename?: 'Error', attribute: string, message: string }> | null } | null };

export type CreatePlayerButtonFragment = { __typename?: 'Event', id: string };

export type EventLayoutFragment = { __typename?: 'Event', name: string, id: string };

export type EventListFragment = { __typename?: 'EventConnection', nodes: Array<{ __typename?: 'Event', id: string, name: string }> };

export type EventListItemFragment = { __typename?: 'Event', id: string, name: string };

export type EventNavFragment = { __typename?: 'Event', id: string };

export type PlayersForPairingsQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type PlayersForPairingsQuery = { __typename?: 'Query', event: { __typename?: 'Event', id: string, players: { __typename?: 'PlayerConnection', nodes: Array<{ __typename?: 'Player', id: string, name: string }> } } };

export type PlayerTableFragment = { __typename?: 'Player', id: string, name: string, paid: boolean, dropped: boolean, winsCount: number, drawsCount: number, lossesCount: number, score: number };

export type PlayerActionsDropdownFragment = { __typename?: 'Player', id: string, paid: boolean, dropped: boolean };

export type PlayerActionsUpdateMutationVariables = Exact<{
  id: Scalars['ID'];
  input: PlayerInput;
}>;


export type PlayerActionsUpdateMutation = { __typename?: 'Mutation', playerUpdate?: { __typename?: 'UpdatePlayerPayload', player?: { __typename?: 'Player', id: string, paid: boolean, dropped: boolean } | null, errors?: Array<{ __typename?: 'Error', attribute: string, message: string }> | null } | null };

export type PlayerActionsDeleteMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type PlayerActionsDeleteMutation = { __typename?: 'Mutation', playerDelete?: { __typename?: 'DeletePlayerPayload', success?: boolean | null, errors?: Array<{ __typename?: 'Error', attribute: string, message: string }> | null } | null };

export type SlipEventFragment = { __typename?: 'Event', id: string, name: string };

export type SlipRoundFragment = { __typename?: 'Round', id: string, number: number };

export type SlipMatchFragment = { __typename?: 'Match', id: string, winnerId?: string | null, draw: boolean, player1: { __typename?: 'Player', id: string, name: string, score: number }, player2?: { __typename?: 'Player', id: string, name: string, score: number } | null };

export type ErrorsFragment = { __typename?: 'Error', attribute: string, message: string };

export type EventShowQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type EventShowQuery = { __typename?: 'Query', event: { __typename?: 'Event', id: string, name: string } };

export type EventMatchesQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type EventMatchesQuery = { __typename?: 'Query', event: { __typename?: 'Event', id: string, name: string, players: { __typename?: 'PlayerConnection', totalCount: number }, rounds: Array<{ __typename?: 'Round', id: string, number: number, matches: Array<{ __typename?: 'Match', id: string, winnerId?: string | null, draw: boolean, player1: { __typename?: 'Player', id: string, name: string }, player2?: { __typename?: 'Player', id: string, name: string } | null }> }> } };

export type EventPlayersQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type EventPlayersQuery = { __typename?: 'Query', event: { __typename?: 'Event', id: string, name: string, players: { __typename?: 'PlayerConnection', nodes: Array<{ __typename?: 'Player', id: string, name: string, paid: boolean, dropped: boolean, winsCount: number, drawsCount: number, lossesCount: number, score: number }> } } };

export type EventSlipsQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type EventSlipsQuery = { __typename?: 'Query', event: { __typename?: 'Event', id: string, name: string, rounds: Array<{ __typename?: 'Round', id: string, number: number, matches: Array<{ __typename?: 'Match', id: string, winnerId?: string | null, draw: boolean, player1: { __typename?: 'Player', id: string, name: string, score: number }, player2?: { __typename?: 'Player', id: string, name: string, score: number } | null }> }> } };

export type EventsIndexQueryVariables = Exact<{ [key: string]: never; }>;


export type EventsIndexQuery = { __typename?: 'Query', events: { __typename?: 'EventConnection', nodes: Array<{ __typename?: 'Event', id: string, name: string }> } };

export const CreatePlayerButtonFragmentDoc = gql`
    fragment CreatePlayerButton on Event {
  id
}
    `;
export const EventNavFragmentDoc = gql`
    fragment EventNav on Event {
  id
}
    `;
export const EventLayoutFragmentDoc = gql`
    fragment EventLayout on Event {
  name
  ...EventNav
}
    ${EventNavFragmentDoc}`;
export const EventListItemFragmentDoc = gql`
    fragment EventListItem on Event {
  id
  name
}
    `;
export const EventListFragmentDoc = gql`
    fragment EventList on EventConnection {
  nodes {
    id
    ...EventListItem
  }
}
    ${EventListItemFragmentDoc}`;
export const PlayerActionsDropdownFragmentDoc = gql`
    fragment PlayerActionsDropdown on Player {
  id
  paid
  dropped
}
    `;
export const PlayerTableFragmentDoc = gql`
    fragment PlayerTable on Player {
  id
  name
  paid
  dropped
  winsCount
  drawsCount
  lossesCount
  score
  ...PlayerActionsDropdown
}
    ${PlayerActionsDropdownFragmentDoc}`;
export const SlipEventFragmentDoc = gql`
    fragment SlipEvent on Event {
  id
  name
}
    `;
export const SlipRoundFragmentDoc = gql`
    fragment SlipRound on Round {
  id
  number
}
    `;
export const SlipMatchFragmentDoc = gql`
    fragment SlipMatch on Match {
  id
  player1 {
    id
    name
    score
  }
  player2 {
    id
    name
    score
  }
  winnerId
  draw
}
    `;
export const ErrorsFragmentDoc = gql`
    fragment Errors on Error {
  attribute
  message(full: true)
}
    `;
export const CreateEventDocument = gql`
    mutation CreateEvent($input: EventInput!) {
  eventCreate(input: {eventInput: $input}) {
    event {
      id
      name
    }
    errors {
      ...Errors
    }
  }
}
    ${ErrorsFragmentDoc}`;
export type CreateEventMutationFn = Apollo.MutationFunction<CreateEventMutation, CreateEventMutationVariables>;

/**
 * __useCreateEventMutation__
 *
 * To run a mutation, you first call `useCreateEventMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateEventMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createEventMutation, { data, loading, error }] = useCreateEventMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateEventMutation(baseOptions?: Apollo.MutationHookOptions<CreateEventMutation, CreateEventMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateEventMutation, CreateEventMutationVariables>(CreateEventDocument, options);
      }
export type CreateEventMutationHookResult = ReturnType<typeof useCreateEventMutation>;
export type CreateEventMutationResult = Apollo.MutationResult<CreateEventMutation>;
export type CreateEventMutationOptions = Apollo.BaseMutationOptions<CreateEventMutation, CreateEventMutationVariables>;
export const CreatePlayerDocument = gql`
    mutation CreatePlayer($eventID: ID!, $input: PlayerInput!) {
  playerCreate(input: {eventId: $eventID, playerInput: $input}) {
    player {
      id
    }
    errors {
      ...Errors
    }
  }
}
    ${ErrorsFragmentDoc}`;
export type CreatePlayerMutationFn = Apollo.MutationFunction<CreatePlayerMutation, CreatePlayerMutationVariables>;

/**
 * __useCreatePlayerMutation__
 *
 * To run a mutation, you first call `useCreatePlayerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePlayerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPlayerMutation, { data, loading, error }] = useCreatePlayerMutation({
 *   variables: {
 *      eventID: // value for 'eventID'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreatePlayerMutation(baseOptions?: Apollo.MutationHookOptions<CreatePlayerMutation, CreatePlayerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreatePlayerMutation, CreatePlayerMutationVariables>(CreatePlayerDocument, options);
      }
export type CreatePlayerMutationHookResult = ReturnType<typeof useCreatePlayerMutation>;
export type CreatePlayerMutationResult = Apollo.MutationResult<CreatePlayerMutation>;
export type CreatePlayerMutationOptions = Apollo.BaseMutationOptions<CreatePlayerMutation, CreatePlayerMutationVariables>;
export const PlayersForPairingsDocument = gql`
    query PlayersForPairings($id: ID!) {
  event(id: $id) {
    id
    players(activeOnly: true) {
      nodes {
        id
        name
      }
    }
  }
}
    `;

/**
 * __usePlayersForPairingsQuery__
 *
 * To run a query within a React component, call `usePlayersForPairingsQuery` and pass it any options that fit your needs.
 * When your component renders, `usePlayersForPairingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePlayersForPairingsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePlayersForPairingsQuery(baseOptions: Apollo.QueryHookOptions<PlayersForPairingsQuery, PlayersForPairingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PlayersForPairingsQuery, PlayersForPairingsQueryVariables>(PlayersForPairingsDocument, options);
      }
export function usePlayersForPairingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PlayersForPairingsQuery, PlayersForPairingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PlayersForPairingsQuery, PlayersForPairingsQueryVariables>(PlayersForPairingsDocument, options);
        }
export type PlayersForPairingsQueryHookResult = ReturnType<typeof usePlayersForPairingsQuery>;
export type PlayersForPairingsLazyQueryHookResult = ReturnType<typeof usePlayersForPairingsLazyQuery>;
export type PlayersForPairingsQueryResult = Apollo.QueryResult<PlayersForPairingsQuery, PlayersForPairingsQueryVariables>;
export const PlayerActionsUpdateDocument = gql`
    mutation PlayerActionsUpdate($id: ID!, $input: PlayerInput!) {
  playerUpdate(input: {id: $id, playerInput: $input}) {
    player {
      id
      ...PlayerActionsDropdown
    }
    errors {
      attribute
      message
    }
  }
}
    ${PlayerActionsDropdownFragmentDoc}`;
export type PlayerActionsUpdateMutationFn = Apollo.MutationFunction<PlayerActionsUpdateMutation, PlayerActionsUpdateMutationVariables>;

/**
 * __usePlayerActionsUpdateMutation__
 *
 * To run a mutation, you first call `usePlayerActionsUpdateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePlayerActionsUpdateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [playerActionsUpdateMutation, { data, loading, error }] = usePlayerActionsUpdateMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function usePlayerActionsUpdateMutation(baseOptions?: Apollo.MutationHookOptions<PlayerActionsUpdateMutation, PlayerActionsUpdateMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PlayerActionsUpdateMutation, PlayerActionsUpdateMutationVariables>(PlayerActionsUpdateDocument, options);
      }
export type PlayerActionsUpdateMutationHookResult = ReturnType<typeof usePlayerActionsUpdateMutation>;
export type PlayerActionsUpdateMutationResult = Apollo.MutationResult<PlayerActionsUpdateMutation>;
export type PlayerActionsUpdateMutationOptions = Apollo.BaseMutationOptions<PlayerActionsUpdateMutation, PlayerActionsUpdateMutationVariables>;
export const PlayerActionsDeleteDocument = gql`
    mutation PlayerActionsDelete($id: ID!) {
  playerDelete(input: {id: $id}) {
    success
    errors {
      attribute
      message
    }
  }
}
    `;
export type PlayerActionsDeleteMutationFn = Apollo.MutationFunction<PlayerActionsDeleteMutation, PlayerActionsDeleteMutationVariables>;

/**
 * __usePlayerActionsDeleteMutation__
 *
 * To run a mutation, you first call `usePlayerActionsDeleteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePlayerActionsDeleteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [playerActionsDeleteMutation, { data, loading, error }] = usePlayerActionsDeleteMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePlayerActionsDeleteMutation(baseOptions?: Apollo.MutationHookOptions<PlayerActionsDeleteMutation, PlayerActionsDeleteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PlayerActionsDeleteMutation, PlayerActionsDeleteMutationVariables>(PlayerActionsDeleteDocument, options);
      }
export type PlayerActionsDeleteMutationHookResult = ReturnType<typeof usePlayerActionsDeleteMutation>;
export type PlayerActionsDeleteMutationResult = Apollo.MutationResult<PlayerActionsDeleteMutation>;
export type PlayerActionsDeleteMutationOptions = Apollo.BaseMutationOptions<PlayerActionsDeleteMutation, PlayerActionsDeleteMutationVariables>;
export const EventShowDocument = gql`
    query EventShow($id: ID!) {
  event(id: $id) {
    id
    name
    ...EventLayout
  }
}
    ${EventLayoutFragmentDoc}`;

/**
 * __useEventShowQuery__
 *
 * To run a query within a React component, call `useEventShowQuery` and pass it any options that fit your needs.
 * When your component renders, `useEventShowQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEventShowQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useEventShowQuery(baseOptions: Apollo.QueryHookOptions<EventShowQuery, EventShowQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EventShowQuery, EventShowQueryVariables>(EventShowDocument, options);
      }
export function useEventShowLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventShowQuery, EventShowQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EventShowQuery, EventShowQueryVariables>(EventShowDocument, options);
        }
export type EventShowQueryHookResult = ReturnType<typeof useEventShowQuery>;
export type EventShowLazyQueryHookResult = ReturnType<typeof useEventShowLazyQuery>;
export type EventShowQueryResult = Apollo.QueryResult<EventShowQuery, EventShowQueryVariables>;
export const EventMatchesDocument = gql`
    query EventMatches($id: ID!) {
  event(id: $id) {
    id
    name
    ...EventLayout
    players {
      totalCount
    }
    rounds {
      id
      number
      matches {
        id
        player1 {
          id
          name
        }
        player2 {
          id
          name
        }
        winnerId
        draw
      }
    }
  }
}
    ${EventLayoutFragmentDoc}`;

/**
 * __useEventMatchesQuery__
 *
 * To run a query within a React component, call `useEventMatchesQuery` and pass it any options that fit your needs.
 * When your component renders, `useEventMatchesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEventMatchesQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useEventMatchesQuery(baseOptions: Apollo.QueryHookOptions<EventMatchesQuery, EventMatchesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EventMatchesQuery, EventMatchesQueryVariables>(EventMatchesDocument, options);
      }
export function useEventMatchesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventMatchesQuery, EventMatchesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EventMatchesQuery, EventMatchesQueryVariables>(EventMatchesDocument, options);
        }
export type EventMatchesQueryHookResult = ReturnType<typeof useEventMatchesQuery>;
export type EventMatchesLazyQueryHookResult = ReturnType<typeof useEventMatchesLazyQuery>;
export type EventMatchesQueryResult = Apollo.QueryResult<EventMatchesQuery, EventMatchesQueryVariables>;
export const EventPlayersDocument = gql`
    query EventPlayers($id: ID!) {
  event(id: $id) {
    id
    name
    ...EventLayout
    ...CreatePlayerButton
    players(deleted: false) {
      nodes {
        ...PlayerTable
      }
    }
  }
}
    ${EventLayoutFragmentDoc}
${CreatePlayerButtonFragmentDoc}
${PlayerTableFragmentDoc}`;

/**
 * __useEventPlayersQuery__
 *
 * To run a query within a React component, call `useEventPlayersQuery` and pass it any options that fit your needs.
 * When your component renders, `useEventPlayersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEventPlayersQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useEventPlayersQuery(baseOptions: Apollo.QueryHookOptions<EventPlayersQuery, EventPlayersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EventPlayersQuery, EventPlayersQueryVariables>(EventPlayersDocument, options);
      }
export function useEventPlayersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventPlayersQuery, EventPlayersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EventPlayersQuery, EventPlayersQueryVariables>(EventPlayersDocument, options);
        }
export type EventPlayersQueryHookResult = ReturnType<typeof useEventPlayersQuery>;
export type EventPlayersLazyQueryHookResult = ReturnType<typeof useEventPlayersLazyQuery>;
export type EventPlayersQueryResult = Apollo.QueryResult<EventPlayersQuery, EventPlayersQueryVariables>;
export const EventSlipsDocument = gql`
    query EventSlips($id: ID!) {
  event(id: $id) {
    id
    name
    ...EventLayout
    ...SlipEvent
    rounds {
      id
      ...SlipRound
      matches {
        ...SlipMatch
      }
    }
  }
}
    ${EventLayoutFragmentDoc}
${SlipEventFragmentDoc}
${SlipRoundFragmentDoc}
${SlipMatchFragmentDoc}`;

/**
 * __useEventSlipsQuery__
 *
 * To run a query within a React component, call `useEventSlipsQuery` and pass it any options that fit your needs.
 * When your component renders, `useEventSlipsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEventSlipsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useEventSlipsQuery(baseOptions: Apollo.QueryHookOptions<EventSlipsQuery, EventSlipsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EventSlipsQuery, EventSlipsQueryVariables>(EventSlipsDocument, options);
      }
export function useEventSlipsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventSlipsQuery, EventSlipsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EventSlipsQuery, EventSlipsQueryVariables>(EventSlipsDocument, options);
        }
export type EventSlipsQueryHookResult = ReturnType<typeof useEventSlipsQuery>;
export type EventSlipsLazyQueryHookResult = ReturnType<typeof useEventSlipsLazyQuery>;
export type EventSlipsQueryResult = Apollo.QueryResult<EventSlipsQuery, EventSlipsQueryVariables>;
export const EventsIndexDocument = gql`
    query EventsIndex {
  events {
    ...EventList
  }
}
    ${EventListFragmentDoc}`;

/**
 * __useEventsIndexQuery__
 *
 * To run a query within a React component, call `useEventsIndexQuery` and pass it any options that fit your needs.
 * When your component renders, `useEventsIndexQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEventsIndexQuery({
 *   variables: {
 *   },
 * });
 */
export function useEventsIndexQuery(baseOptions?: Apollo.QueryHookOptions<EventsIndexQuery, EventsIndexQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EventsIndexQuery, EventsIndexQueryVariables>(EventsIndexDocument, options);
      }
export function useEventsIndexLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventsIndexQuery, EventsIndexQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EventsIndexQuery, EventsIndexQueryVariables>(EventsIndexDocument, options);
        }
export type EventsIndexQueryHookResult = ReturnType<typeof useEventsIndexQuery>;
export type EventsIndexLazyQueryHookResult = ReturnType<typeof useEventsIndexLazyQuery>;
export type EventsIndexQueryResult = Apollo.QueryResult<EventsIndexQuery, EventsIndexQueryVariables>;

      export interface PossibleTypesResultData {
        possibleTypes: {
          [key: string]: string[]
        }
      }
      const result: PossibleTypesResultData = {
  "possibleTypes": {}
};
      export default result;
    
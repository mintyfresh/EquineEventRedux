import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** An ISO 8601-encoded datetime */
  ISO8601DateTime: any;
};

/** Autogenerated input type of DeleteEvent */
export type DeleteEventInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteEvent */
export type DeleteEventPayload = {
  __typename?: 'DeleteEventPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  success?: Maybe<Scalars['Boolean']>;
};

/** Autogenerated input type of DeletePlayer */
export type DeletePlayerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated return type of DeletePlayer */
export type DeletePlayerPayload = {
  __typename?: 'DeletePlayerPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  success?: Maybe<Scalars['Boolean']>;
};

/** Autogenerated input type of DeleteRound */
export type DeleteRoundInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteRound */
export type DeleteRoundPayload = {
  __typename?: 'DeleteRoundPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  success?: Maybe<Scalars['Boolean']>;
};

export type Error = {
  __typename?: 'Error';
  attribute: Scalars['String'];
  message: Scalars['String'];
};


export type ErrorMessageArgs = {
  full?: InputMaybe<Scalars['Boolean']>;
};

export type Event = {
  __typename?: 'Event';
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  name: Scalars['String'];
  players: Array<Player>;
  rounds: Array<Round>;
};


export type EventPlayersArgs = {
  deleted?: InputMaybe<Scalars['Boolean']>;
};

/** The connection type for Event. */
export type EventConnection = {
  __typename?: 'EventConnection';
  /** A list of edges. */
  edges: Array<Maybe<EventEdge>>;
  /** A list of nodes. */
  nodes: Array<Event>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of EventCreate */
export type EventCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  eventInput: EventInput;
};

/** Autogenerated return type of EventCreate */
export type EventCreatePayload = {
  __typename?: 'EventCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  event?: Maybe<Event>;
};

/** An edge in a connection. */
export type EventEdge = {
  __typename?: 'EventEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Event>;
};

export type EventInput = {
  name?: InputMaybe<Scalars['String']>;
};

export type Match = {
  __typename?: 'Match';
  draw: Scalars['Boolean'];
  id: Scalars['ID'];
  player1: Player;
  player1Id: Scalars['ID'];
  player2?: Maybe<Player>;
  player2Id?: Maybe<Scalars['ID']>;
  roundId: Scalars['ID'];
  winnerId?: Maybe<Scalars['ID']>;
};

export type MatchInput = {
  draw?: InputMaybe<Scalars['Boolean']>;
  winnerId?: InputMaybe<Scalars['ID']>;
};

export type Mutation = {
  __typename?: 'Mutation';
  /** Creates a new Event */
  eventCreate?: Maybe<EventCreatePayload>;
  /** Deletes an existing Event by ID */
  eventDelete?: Maybe<DeleteEventPayload>;
  /** Updates an existing Event by ID */
  eventUpdate?: Maybe<UpdateEventPayload>;
  /** Updates an existing Match by ID */
  matchUpdate?: Maybe<UpdateMatchPayload>;
  /** Creates a new Player */
  playerCreate?: Maybe<PlayerCreatePayload>;
  /** Deletes an existing Player by ID */
  playerDelete?: Maybe<DeletePlayerPayload>;
  /** Updates an existing Player by ID */
  playerUpdate?: Maybe<UpdatePlayerPayload>;
  /** Create a new Round */
  roundCreate?: Maybe<RoundCreatePayload>;
  /** Deletes an existing Round by ID */
  roundDelete?: Maybe<DeleteRoundPayload>;
  /** Updates the Match pairings for a Round */
  roundUpdatePairings?: Maybe<RoundUpdatePairingsPayload>;
};


export type MutationEventCreateArgs = {
  input: EventCreateInput;
};


export type MutationEventDeleteArgs = {
  input: DeleteEventInput;
};


export type MutationEventUpdateArgs = {
  input: UpdateEventInput;
};


export type MutationMatchUpdateArgs = {
  input: UpdateMatchInput;
};


export type MutationPlayerCreateArgs = {
  input: PlayerCreateInput;
};


export type MutationPlayerDeleteArgs = {
  input: DeletePlayerInput;
};


export type MutationPlayerUpdateArgs = {
  input: UpdatePlayerInput;
};


export type MutationRoundCreateArgs = {
  input: RoundCreateInput;
};


export type MutationRoundDeleteArgs = {
  input: DeleteRoundInput;
};


export type MutationRoundUpdatePairingsArgs = {
  input: RoundUpdatePairingsInput;
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']>;
};

export type Player = {
  __typename?: 'Player';
  deleted: Scalars['Boolean'];
  deletedAt?: Maybe<Scalars['ISO8601DateTime']>;
  drawsCount: Scalars['Int'];
  dropped: Scalars['Boolean'];
  eventId: Scalars['ID'];
  id: Scalars['ID'];
  lossesCount: Scalars['Int'];
  name: Scalars['String'];
  paid: Scalars['Boolean'];
  score: Scalars['Int'];
  winsCount: Scalars['Int'];
};

/** Autogenerated input type of PlayerCreate */
export type PlayerCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the Event to add the Player to */
  eventId: Scalars['ID'];
  playerInput: PlayerInput;
};

/** Autogenerated return type of PlayerCreate */
export type PlayerCreatePayload = {
  __typename?: 'PlayerCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  /** The Event that the Player was added to */
  event?: Maybe<Event>;
  player?: Maybe<Player>;
};

export type PlayerInput = {
  dropped?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  paid?: InputMaybe<Scalars['Boolean']>;
};

export type Query = {
  __typename?: 'Query';
  /** Finds a Event by ID */
  event: Event;
  /** Finds a list of Event objects */
  events: EventConnection;
  /** Finds a Match by ID */
  match: Match;
  /** Finds a Player by ID */
  player: Player;
  /** Finds a Round by ID */
  round: Round;
  roundProposePairings: Array<Array<Maybe<Player>>>;
};


export type QueryEventArgs = {
  id: Scalars['ID'];
};


export type QueryEventsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueryMatchArgs = {
  id: Scalars['ID'];
};


export type QueryPlayerArgs = {
  id: Scalars['ID'];
};


export type QueryRoundArgs = {
  id: Scalars['ID'];
};


export type QueryRoundProposePairingsArgs = {
  roundId: Scalars['ID'];
};

export type Round = {
  __typename?: 'Round';
  eventId: Scalars['ID'];
  id: Scalars['ID'];
  matches: Array<Match>;
  number: Scalars['Int'];
};

/** Autogenerated input type of RoundCreate */
export type RoundCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the Event to add the Round to */
  eventId: Scalars['ID'];
};

/** Autogenerated return type of RoundCreate */
export type RoundCreatePayload = {
  __typename?: 'RoundCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  /** The Event that the Round was added to */
  event?: Maybe<Event>;
  /** The Round that was created */
  round?: Maybe<Round>;
};

/** Autogenerated input type of RoundUpdatePairings */
export type RoundUpdatePairingsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The IDs of the Players to pair */
  pairings: Array<Array<InputMaybe<Scalars['ID']>>>;
  /** The ID of the Round to update */
  roundId: Scalars['ID'];
};

/** Autogenerated return type of RoundUpdatePairings */
export type RoundUpdatePairingsPayload = {
  __typename?: 'RoundUpdatePairingsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  round?: Maybe<Round>;
};

/** Autogenerated input type of UpdateEvent */
export type UpdateEventInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  eventInput: EventInput;
  id: Scalars['ID'];
};

/** Autogenerated return type of UpdateEvent */
export type UpdateEventPayload = {
  __typename?: 'UpdateEventPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  event?: Maybe<Event>;
};

/** Autogenerated input type of UpdateMatch */
export type UpdateMatchInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  matchInput: MatchInput;
};

/** Autogenerated return type of UpdateMatch */
export type UpdateMatchPayload = {
  __typename?: 'UpdateMatchPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  match?: Maybe<Match>;
};

/** Autogenerated input type of UpdatePlayer */
export type UpdatePlayerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  playerInput: PlayerInput;
};

/** Autogenerated return type of UpdatePlayer */
export type UpdatePlayerPayload = {
  __typename?: 'UpdatePlayerPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Error>>;
  player?: Maybe<Player>;
};

export type CreateEventMutationVariables = Exact<{
  input: EventInput;
}>;


export type CreateEventMutation = { __typename?: 'Mutation', eventCreate?: { __typename?: 'EventCreatePayload', event?: { __typename?: 'Event', id: string, name: string } | null, errors?: Array<{ __typename?: 'Error', attribute: string, message: string }> | null } | null };

export type EventLayoutFragment = { __typename?: 'Event', name: string, id: string };

export type EventListFragment = { __typename?: 'EventConnection', nodes: Array<{ __typename?: 'Event', id: string, name: string }> };

export type EventListItemFragment = { __typename?: 'Event', id: string, name: string };

export type EventNavFragment = { __typename?: 'Event', id: string };

export type PlayerTableFragment = { __typename?: 'Player', id: string, name: string, paid: boolean, dropped: boolean, winsCount: number, drawsCount: number, lossesCount: number, score: number };

export type PlayerActionsDropdownFragment = { __typename?: 'Player', id: string, paid: boolean, dropped: boolean };

export type PlayerActionsUpdateMutationVariables = Exact<{
  id: Scalars['ID'];
  input: PlayerInput;
}>;


export type PlayerActionsUpdateMutation = { __typename?: 'Mutation', playerUpdate?: { __typename?: 'UpdatePlayerPayload', player?: { __typename?: 'Player', id: string, paid: boolean, dropped: boolean } | null, errors?: Array<{ __typename?: 'Error', attribute: string, message: string }> | null } | null };

export type PlayerActionsDeleteMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type PlayerActionsDeleteMutation = { __typename?: 'Mutation', playerDelete?: { __typename?: 'DeletePlayerPayload', success?: boolean | null, errors?: Array<{ __typename?: 'Error', attribute: string, message: string }> | null } | null };

export type ErrorsFragment = { __typename?: 'Error', attribute: string, message: string };

export type EventShowQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type EventShowQuery = { __typename?: 'Query', event: { __typename?: 'Event', id: string, name: string } };

export type EventMatchesQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type EventMatchesQuery = { __typename?: 'Query', event: { __typename?: 'Event', id: string, name: string, rounds: Array<{ __typename?: 'Round', id: string, number: number, matches: Array<{ __typename?: 'Match', id: string, winnerId?: string | null, draw: boolean, player1: { __typename?: 'Player', id: string, name: string }, player2?: { __typename?: 'Player', id: string, name: string } | null }> }> } };

export type EventPlayersQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type EventPlayersQuery = { __typename?: 'Query', event: { __typename?: 'Event', id: string, name: string, players: Array<{ __typename?: 'Player', id: string, name: string, paid: boolean, dropped: boolean, winsCount: number, drawsCount: number, lossesCount: number, score: number }> } };

export type EventsIndexQueryVariables = Exact<{ [key: string]: never; }>;


export type EventsIndexQuery = { __typename?: 'Query', events: { __typename?: 'EventConnection', nodes: Array<{ __typename?: 'Event', id: string, name: string }> } };

export const EventNavFragmentDoc = gql`
    fragment EventNav on Event {
  id
}
    `;
export const EventLayoutFragmentDoc = gql`
    fragment EventLayout on Event {
  name
  ...EventNav
}
    ${EventNavFragmentDoc}`;
export const EventListItemFragmentDoc = gql`
    fragment EventListItem on Event {
  id
  name
}
    `;
export const EventListFragmentDoc = gql`
    fragment EventList on EventConnection {
  nodes {
    id
    ...EventListItem
  }
}
    ${EventListItemFragmentDoc}`;
export const PlayerActionsDropdownFragmentDoc = gql`
    fragment PlayerActionsDropdown on Player {
  id
  paid
  dropped
}
    `;
export const PlayerTableFragmentDoc = gql`
    fragment PlayerTable on Player {
  id
  name
  paid
  dropped
  winsCount
  drawsCount
  lossesCount
  score
  ...PlayerActionsDropdown
}
    ${PlayerActionsDropdownFragmentDoc}`;
export const ErrorsFragmentDoc = gql`
    fragment Errors on Error {
  attribute
  message(full: true)
}
    `;
export const CreateEventDocument = gql`
    mutation CreateEvent($input: EventInput!) {
  eventCreate(input: {eventInput: $input}) {
    event {
      id
      name
    }
    errors {
      ...Errors
    }
  }
}
    ${ErrorsFragmentDoc}`;
export type CreateEventMutationFn = Apollo.MutationFunction<CreateEventMutation, CreateEventMutationVariables>;

/**
 * __useCreateEventMutation__
 *
 * To run a mutation, you first call `useCreateEventMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateEventMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createEventMutation, { data, loading, error }] = useCreateEventMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateEventMutation(baseOptions?: Apollo.MutationHookOptions<CreateEventMutation, CreateEventMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateEventMutation, CreateEventMutationVariables>(CreateEventDocument, options);
      }
export type CreateEventMutationHookResult = ReturnType<typeof useCreateEventMutation>;
export type CreateEventMutationResult = Apollo.MutationResult<CreateEventMutation>;
export type CreateEventMutationOptions = Apollo.BaseMutationOptions<CreateEventMutation, CreateEventMutationVariables>;
export const PlayerActionsUpdateDocument = gql`
    mutation PlayerActionsUpdate($id: ID!, $input: PlayerInput!) {
  playerUpdate(input: {id: $id, playerInput: $input}) {
    player {
      id
      ...PlayerActionsDropdown
    }
    errors {
      attribute
      message
    }
  }
}
    ${PlayerActionsDropdownFragmentDoc}`;
export type PlayerActionsUpdateMutationFn = Apollo.MutationFunction<PlayerActionsUpdateMutation, PlayerActionsUpdateMutationVariables>;

/**
 * __usePlayerActionsUpdateMutation__
 *
 * To run a mutation, you first call `usePlayerActionsUpdateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePlayerActionsUpdateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [playerActionsUpdateMutation, { data, loading, error }] = usePlayerActionsUpdateMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function usePlayerActionsUpdateMutation(baseOptions?: Apollo.MutationHookOptions<PlayerActionsUpdateMutation, PlayerActionsUpdateMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PlayerActionsUpdateMutation, PlayerActionsUpdateMutationVariables>(PlayerActionsUpdateDocument, options);
      }
export type PlayerActionsUpdateMutationHookResult = ReturnType<typeof usePlayerActionsUpdateMutation>;
export type PlayerActionsUpdateMutationResult = Apollo.MutationResult<PlayerActionsUpdateMutation>;
export type PlayerActionsUpdateMutationOptions = Apollo.BaseMutationOptions<PlayerActionsUpdateMutation, PlayerActionsUpdateMutationVariables>;
export const PlayerActionsDeleteDocument = gql`
    mutation PlayerActionsDelete($id: ID!) {
  playerDelete(input: {id: $id}) {
    success
    errors {
      attribute
      message
    }
  }
}
    `;
export type PlayerActionsDeleteMutationFn = Apollo.MutationFunction<PlayerActionsDeleteMutation, PlayerActionsDeleteMutationVariables>;

/**
 * __usePlayerActionsDeleteMutation__
 *
 * To run a mutation, you first call `usePlayerActionsDeleteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePlayerActionsDeleteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [playerActionsDeleteMutation, { data, loading, error }] = usePlayerActionsDeleteMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePlayerActionsDeleteMutation(baseOptions?: Apollo.MutationHookOptions<PlayerActionsDeleteMutation, PlayerActionsDeleteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PlayerActionsDeleteMutation, PlayerActionsDeleteMutationVariables>(PlayerActionsDeleteDocument, options);
      }
export type PlayerActionsDeleteMutationHookResult = ReturnType<typeof usePlayerActionsDeleteMutation>;
export type PlayerActionsDeleteMutationResult = Apollo.MutationResult<PlayerActionsDeleteMutation>;
export type PlayerActionsDeleteMutationOptions = Apollo.BaseMutationOptions<PlayerActionsDeleteMutation, PlayerActionsDeleteMutationVariables>;
export const EventShowDocument = gql`
    query EventShow($id: ID!) {
  event(id: $id) {
    id
    name
    ...EventLayout
  }
}
    ${EventLayoutFragmentDoc}`;

/**
 * __useEventShowQuery__
 *
 * To run a query within a React component, call `useEventShowQuery` and pass it any options that fit your needs.
 * When your component renders, `useEventShowQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEventShowQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useEventShowQuery(baseOptions: Apollo.QueryHookOptions<EventShowQuery, EventShowQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EventShowQuery, EventShowQueryVariables>(EventShowDocument, options);
      }
export function useEventShowLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventShowQuery, EventShowQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EventShowQuery, EventShowQueryVariables>(EventShowDocument, options);
        }
export type EventShowQueryHookResult = ReturnType<typeof useEventShowQuery>;
export type EventShowLazyQueryHookResult = ReturnType<typeof useEventShowLazyQuery>;
export type EventShowQueryResult = Apollo.QueryResult<EventShowQuery, EventShowQueryVariables>;
export const EventMatchesDocument = gql`
    query EventMatches($id: ID!) {
  event(id: $id) {
    id
    name
    ...EventLayout
    rounds {
      id
      number
      matches {
        id
        player1 {
          id
          name
        }
        player2 {
          id
          name
        }
        winnerId
        draw
      }
    }
  }
}
    ${EventLayoutFragmentDoc}`;

/**
 * __useEventMatchesQuery__
 *
 * To run a query within a React component, call `useEventMatchesQuery` and pass it any options that fit your needs.
 * When your component renders, `useEventMatchesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEventMatchesQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useEventMatchesQuery(baseOptions: Apollo.QueryHookOptions<EventMatchesQuery, EventMatchesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EventMatchesQuery, EventMatchesQueryVariables>(EventMatchesDocument, options);
      }
export function useEventMatchesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventMatchesQuery, EventMatchesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EventMatchesQuery, EventMatchesQueryVariables>(EventMatchesDocument, options);
        }
export type EventMatchesQueryHookResult = ReturnType<typeof useEventMatchesQuery>;
export type EventMatchesLazyQueryHookResult = ReturnType<typeof useEventMatchesLazyQuery>;
export type EventMatchesQueryResult = Apollo.QueryResult<EventMatchesQuery, EventMatchesQueryVariables>;
export const EventPlayersDocument = gql`
    query EventPlayers($id: ID!) {
  event(id: $id) {
    id
    name
    ...EventLayout
    players(deleted: false) {
      ...PlayerTable
    }
  }
}
    ${EventLayoutFragmentDoc}
${PlayerTableFragmentDoc}`;

/**
 * __useEventPlayersQuery__
 *
 * To run a query within a React component, call `useEventPlayersQuery` and pass it any options that fit your needs.
 * When your component renders, `useEventPlayersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEventPlayersQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useEventPlayersQuery(baseOptions: Apollo.QueryHookOptions<EventPlayersQuery, EventPlayersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EventPlayersQuery, EventPlayersQueryVariables>(EventPlayersDocument, options);
      }
export function useEventPlayersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventPlayersQuery, EventPlayersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EventPlayersQuery, EventPlayersQueryVariables>(EventPlayersDocument, options);
        }
export type EventPlayersQueryHookResult = ReturnType<typeof useEventPlayersQuery>;
export type EventPlayersLazyQueryHookResult = ReturnType<typeof useEventPlayersLazyQuery>;
export type EventPlayersQueryResult = Apollo.QueryResult<EventPlayersQuery, EventPlayersQueryVariables>;
export const EventsIndexDocument = gql`
    query EventsIndex {
  events {
    ...EventList
  }
}
    ${EventListFragmentDoc}`;

/**
 * __useEventsIndexQuery__
 *
 * To run a query within a React component, call `useEventsIndexQuery` and pass it any options that fit your needs.
 * When your component renders, `useEventsIndexQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEventsIndexQuery({
 *   variables: {
 *   },
 * });
 */
export function useEventsIndexQuery(baseOptions?: Apollo.QueryHookOptions<EventsIndexQuery, EventsIndexQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EventsIndexQuery, EventsIndexQueryVariables>(EventsIndexDocument, options);
      }
export function useEventsIndexLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventsIndexQuery, EventsIndexQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EventsIndexQuery, EventsIndexQueryVariables>(EventsIndexDocument, options);
        }
export type EventsIndexQueryHookResult = ReturnType<typeof useEventsIndexQuery>;
export type EventsIndexLazyQueryHookResult = ReturnType<typeof useEventsIndexLazyQuery>;
export type EventsIndexQueryResult = Apollo.QueryResult<EventsIndexQuery, EventsIndexQueryVariables>;

      export interface PossibleTypesResultData {
        possibleTypes: {
          [key: string]: string[]
        }
      }
      const result: PossibleTypesResultData = {
  "possibleTypes": {}
};
      export default result;
    
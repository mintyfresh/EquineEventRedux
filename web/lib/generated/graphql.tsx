import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** An ISO 8601-encoded datetime */
  ISO8601DateTime: any;
};

/** Autogenerated return type of CreateEvent */
export type CreateEventPayload = {
  __typename?: 'CreateEventPayload';
  errors?: Maybe<Array<Error>>;
  event?: Maybe<Event>;
};

/** Autogenerated return type of DeleteEvent */
export type DeleteEventPayload = {
  __typename?: 'DeleteEventPayload';
  errors?: Maybe<Array<Error>>;
  success?: Maybe<Scalars['Boolean']>;
};

/** Autogenerated return type of DeletePlayer */
export type DeletePlayerPayload = {
  __typename?: 'DeletePlayerPayload';
  errors?: Maybe<Array<Error>>;
  success?: Maybe<Scalars['Boolean']>;
};

/** Autogenerated return type of DeleteRound */
export type DeleteRoundPayload = {
  __typename?: 'DeleteRoundPayload';
  errors?: Maybe<Array<Error>>;
  success?: Maybe<Scalars['Boolean']>;
};

export type Error = {
  __typename?: 'Error';
  attribute: Scalars['String'];
  message: Scalars['String'];
};


export type ErrorMessageArgs = {
  full?: InputMaybe<Scalars['Boolean']>;
};

export type Event = {
  __typename?: 'Event';
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  name: Scalars['String'];
  players: PlayerConnection;
  rounds: Array<Round>;
};


export type EventPlayersArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  deleted?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<EventPlayersOrderBy>;
  orderByDirection?: InputMaybe<OrderByDirection>;
};


export type EventRoundsArgs = {
  orderBy?: InputMaybe<EventRoundsOrderBy>;
  orderByDirection?: InputMaybe<OrderByDirection>;
};

/** The connection type for Event. */
export type EventConnection = {
  __typename?: 'EventConnection';
  /** A list of edges. */
  edges: Array<EventEdge>;
  /** A list of nodes. */
  nodes: Array<Event>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type EventEdge = {
  __typename?: 'EventEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Event>;
};

/** Autogenerated return type of EventGeneratePairings */
export type EventGeneratePairingsPayload = {
  __typename?: 'EventGeneratePairingsPayload';
  pairings: Array<Pairing>;
};

export type EventInput = {
  name?: InputMaybe<Scalars['String']>;
};

export enum EventPlayersOrderBy {
  DrawsCount = 'DRAWS_COUNT',
  LossesCount = 'LOSSES_COUNT',
  Name = 'NAME',
  Score = 'SCORE',
  WinsCount = 'WINS_COUNT'
}

export enum EventRoundsOrderBy {
  Number = 'NUMBER'
}

export type Match = {
  __typename?: 'Match';
  draw: Scalars['Boolean'];
  id: Scalars['ID'];
  player1: Player;
  player1Id: Scalars['ID'];
  player2?: Maybe<Player>;
  player2Id?: Maybe<Scalars['ID']>;
  roundId: Scalars['ID'];
  winnerId?: Maybe<Scalars['ID']>;
};

export type MatchCreateInput = {
  player1Id: Scalars['ID'];
  player2Id?: InputMaybe<Scalars['ID']>;
};

export type MatchUpdateInput = {
  draw?: InputMaybe<Scalars['Boolean']>;
  winnerId?: InputMaybe<Scalars['ID']>;
};

export type Mutation = {
  __typename?: 'Mutation';
  /** Creates a new Event */
  eventCreate?: Maybe<CreateEventPayload>;
  /** Deletes an existing Event by ID */
  eventDelete?: Maybe<DeleteEventPayload>;
  /** Generates a possible list of pairings for a round. */
  eventGeneratePairings?: Maybe<EventGeneratePairingsPayload>;
  /** Updates an existing Event by ID */
  eventUpdate?: Maybe<UpdateEventPayload>;
  /** Updates an existing Match by ID */
  matchUpdate?: Maybe<UpdateMatchPayload>;
  /** Creates a new Player */
  playerCreate?: Maybe<PlayerCreatePayload>;
  /** Deletes an existing Player by ID */
  playerDelete?: Maybe<DeletePlayerPayload>;
  /** Updates an existing Player by ID */
  playerUpdate?: Maybe<UpdatePlayerPayload>;
  /** Creates a new Round */
  roundCreate?: Maybe<RoundCreatePayload>;
  /** Deletes an existing Round by ID */
  roundDelete?: Maybe<DeleteRoundPayload>;
  /** Updates the Match pairings for a Round */
  roundUpdatePairings?: Maybe<RoundUpdatePairingsPayload>;
};


export type MutationEventCreateArgs = {
  input: EventInput;
};


export type MutationEventDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationEventGeneratePairingsArgs = {
  eventId: Scalars['ID'];
  excludePlayerIds?: InputMaybe<Array<Scalars['ID']>>;
};


export type MutationEventUpdateArgs = {
  id: Scalars['ID'];
  input: EventInput;
};


export type MutationMatchUpdateArgs = {
  id: Scalars['ID'];
  input: MatchUpdateInput;
};


export type MutationPlayerCreateArgs = {
  eventId: Scalars['ID'];
  input: PlayerInput;
};


export type MutationPlayerDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationPlayerUpdateArgs = {
  id: Scalars['ID'];
  input: PlayerInput;
};


export type MutationRoundCreateArgs = {
  eventId: Scalars['ID'];
  input: RoundCreateInput;
};


export type MutationRoundDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationRoundUpdatePairingsArgs = {
  pairings: Array<Array<InputMaybe<Scalars['ID']>>>;
  roundId: Scalars['ID'];
};

export enum OrderByDirection {
  Asc = 'ASC',
  Desc = 'DESC'
}

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']>;
};

export type Pairing = {
  __typename?: 'Pairing';
  player1: Player;
  player2?: Maybe<Player>;
};

export type Player = {
  __typename?: 'Player';
  deleted: Scalars['Boolean'];
  deletedAt?: Maybe<Scalars['ISO8601DateTime']>;
  drawsCount: Scalars['Int'];
  dropped: Scalars['Boolean'];
  eventId: Scalars['ID'];
  id: Scalars['ID'];
  lossesCount: Scalars['Int'];
  name: Scalars['String'];
  paid: Scalars['Boolean'];
  score: Scalars['Int'];
  winsCount: Scalars['Int'];
};

/** The connection type for Player. */
export type PlayerConnection = {
  __typename?: 'PlayerConnection';
  /** A list of edges. */
  edges: Array<PlayerEdge>;
  /** A list of nodes. */
  nodes: Array<Player>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** Autogenerated return type of PlayerCreate */
export type PlayerCreatePayload = {
  __typename?: 'PlayerCreatePayload';
  errors?: Maybe<Array<Error>>;
  /** The Event that the Player was added to */
  event?: Maybe<Event>;
  player?: Maybe<Player>;
};

/** An edge in a connection. */
export type PlayerEdge = {
  __typename?: 'PlayerEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Player>;
};

export type PlayerInput = {
  dropped?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  paid?: InputMaybe<Scalars['Boolean']>;
};

export type Query = {
  __typename?: 'Query';
  /** Finds a Event by ID */
  event: Event;
  /** Finds a list of Event objects */
  events: EventConnection;
  /** Finds a Match by ID */
  match: Match;
  /** Finds a Player by ID */
  player: Player;
  /** Finds a Round by ID */
  round: Round;
};


export type QueryEventArgs = {
  id: Scalars['ID'];
};


export type QueryEventsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueryMatchArgs = {
  id: Scalars['ID'];
};


export type QueryPlayerArgs = {
  id: Scalars['ID'];
};


export type QueryRoundArgs = {
  id: Scalars['ID'];
};

export type Round = {
  __typename?: 'Round';
  eventId: Scalars['ID'];
  id: Scalars['ID'];
  matches: Array<Match>;
  number: Scalars['Int'];
};

export type RoundCreateInput = {
  matches: Array<MatchCreateInput>;
};

/** Autogenerated return type of RoundCreate */
export type RoundCreatePayload = {
  __typename?: 'RoundCreatePayload';
  errors?: Maybe<Array<Error>>;
  /** The Event that the Round was added to */
  event?: Maybe<Event>;
  /** The Round that was created */
  round?: Maybe<Round>;
};

/** Autogenerated return type of RoundUpdatePairings */
export type RoundUpdatePairingsPayload = {
  __typename?: 'RoundUpdatePairingsPayload';
  errors?: Maybe<Array<Error>>;
  round?: Maybe<Round>;
};

/** Autogenerated return type of UpdateEvent */
export type UpdateEventPayload = {
  __typename?: 'UpdateEventPayload';
  errors?: Maybe<Array<Error>>;
  event?: Maybe<Event>;
};

/** Autogenerated return type of UpdateMatch */
export type UpdateMatchPayload = {
  __typename?: 'UpdateMatchPayload';
  errors?: Maybe<Array<Error>>;
  match?: Maybe<Match>;
};

/** Autogenerated return type of UpdatePlayer */
export type UpdatePlayerPayload = {
  __typename?: 'UpdatePlayerPayload';
  errors?: Maybe<Array<Error>>;
  player?: Maybe<Player>;
};

export type CreateEventMutationVariables = Exact<{
  input: EventInput;
}>;


export type CreateEventMutation = { __typename?: 'Mutation', eventCreate?: { __typename?: 'CreateEventPayload', event?: { __typename?: 'Event', id: string, name: string } | null, errors?: Array<{ __typename?: 'Error', attribute: string, message: string }> | null } | null };

export type CreatePlayerMutationVariables = Exact<{
  eventID: Scalars['ID'];
  input: PlayerInput;
}>;


export type CreatePlayerMutation = { __typename?: 'Mutation', playerCreate?: { __typename?: 'PlayerCreatePayload', player?: { __typename?: 'Player', id: string } | null, errors?: Array<{ __typename?: 'Error', attribute: string, message: string }> | null } | null };

export type CreatePlayerButtonFragment = { __typename?: 'Event', id: string };

export type CreateRoundButtonFragment = { __typename?: 'Event', id: string };

export type PlayersForRoundCreateQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type PlayersForRoundCreateQuery = { __typename?: 'Query', event: { __typename?: 'Event', id: string, players: { __typename?: 'PlayerConnection', nodes: Array<{ __typename?: 'Player', id: string, name: string }> } } };

export type CreateRoundMutationVariables = Exact<{
  eventId: Scalars['ID'];
  input: RoundCreateInput;
}>;


export type CreateRoundMutation = { __typename?: 'Mutation', roundCreate?: { __typename?: 'RoundCreatePayload', round?: { __typename?: 'Round', id: string } | null, errors?: Array<{ __typename?: 'Error', attribute: string, message: string }> | null } | null };

export type EventLayoutFragment = { __typename?: 'Event', name: string, id: string };

export type EventListFragment = { __typename?: 'EventConnection', nodes: Array<{ __typename?: 'Event', id: string, name: string }> };

export type EventListItemFragment = { __typename?: 'Event', id: string, name: string };

export type EventNavFragment = { __typename?: 'Event', id: string };

export type PlayerTableFragment = { __typename?: 'Player', id: string, name: string, paid: boolean, dropped: boolean, winsCount: number, drawsCount: number, lossesCount: number, score: number };

export type EditPlayerDropdownItemFragment = { __typename?: 'Player', id: string, name: string, paid: boolean, dropped: boolean };

export type EditPlayerMutationVariables = Exact<{
  id: Scalars['ID'];
  input: PlayerInput;
}>;


export type EditPlayerMutation = { __typename?: 'Mutation', playerUpdate?: { __typename?: 'UpdatePlayerPayload', player?: { __typename?: 'Player', id: string, name: string, paid: boolean, dropped: boolean } | null, errors?: Array<{ __typename?: 'Error', attribute: string, message: string }> | null } | null };

export type PlayerActionsDropdownFragment = { __typename?: 'Player', id: string, paid: boolean, dropped: boolean, name: string };

export type PlayerActionsUpdateMutationVariables = Exact<{
  id: Scalars['ID'];
  input: PlayerInput;
}>;


export type PlayerActionsUpdateMutation = { __typename?: 'Mutation', playerUpdate?: { __typename?: 'UpdatePlayerPayload', player?: { __typename?: 'Player', id: string, paid: boolean, dropped: boolean, name: string } | null, errors?: Array<{ __typename?: 'Error', attribute: string, message: string }> | null } | null };

export type PlayerActionsDeleteMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type PlayerActionsDeleteMutation = { __typename?: 'Mutation', playerDelete?: { __typename?: 'DeletePlayerPayload', success?: boolean | null, errors?: Array<{ __typename?: 'Error', attribute: string, message: string }> | null } | null };

export type RoundListFragment = { __typename?: 'Event', rounds: Array<{ __typename?: 'Round', id: string, number: number, matches: Array<{ __typename?: 'Match', id: string, winnerId?: string | null, draw: boolean, player1: { __typename?: 'Player', id: string, name: string }, player2?: { __typename?: 'Player', id: string, name: string } | null }> }> };

export type RoundMatchListItemFragment = { __typename?: 'Match', id: string, winnerId?: string | null, draw: boolean, player1: { __typename?: 'Player', id: string, name: string }, player2?: { __typename?: 'Player', id: string, name: string } | null };

export type RoundModalPlayerFragment = { __typename?: 'Player', id: string, name: string };

export type GeneratePairingsForRoundMutationVariables = Exact<{
  eventId: Scalars['ID'];
  excludePlayerIds?: InputMaybe<Array<Scalars['ID']> | Scalars['ID']>;
}>;


export type GeneratePairingsForRoundMutation = { __typename?: 'Mutation', eventGeneratePairings?: { __typename?: 'EventGeneratePairingsPayload', pairings: Array<{ __typename?: 'Pairing', player1: { __typename?: 'Player', id: string, name: string }, player2?: { __typename?: 'Player', id: string, name: string } | null }> } | null };

export type SlipEventFragment = { __typename?: 'Event', id: string, name: string };

export type SlipRoundFragment = { __typename?: 'Round', id: string, number: number };

export type SlipMatchFragment = { __typename?: 'Match', id: string, winnerId?: string | null, draw: boolean, player1: { __typename?: 'Player', id: string, name: string, score: number }, player2?: { __typename?: 'Player', id: string, name: string, score: number } | null };

export type ErrorsFragment = { __typename?: 'Error', attribute: string, message: string };

export type EventShowQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type EventShowQuery = { __typename?: 'Query', event: { __typename?: 'Event', id: string, name: string } };

export type EventMatchesQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type EventMatchesQuery = { __typename?: 'Query', event: { __typename?: 'Event', id: string, name: string, players: { __typename?: 'PlayerConnection', totalCount: number }, rounds: Array<{ __typename?: 'Round', id: string, number: number, matches: Array<{ __typename?: 'Match', id: string, winnerId?: string | null, draw: boolean, player1: { __typename?: 'Player', id: string, name: string }, player2?: { __typename?: 'Player', id: string, name: string } | null }> }> } };

export type EventPlayersQueryVariables = Exact<{
  id: Scalars['ID'];
  orderBy?: InputMaybe<EventPlayersOrderBy>;
  orderByDirection?: InputMaybe<OrderByDirection>;
}>;


export type EventPlayersQuery = { __typename?: 'Query', event: { __typename?: 'Event', id: string, name: string, players: { __typename?: 'PlayerConnection', nodes: Array<{ __typename?: 'Player', id: string, name: string, paid: boolean, dropped: boolean, winsCount: number, drawsCount: number, lossesCount: number, score: number }> } } };

export type EventSlipsQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type EventSlipsQuery = { __typename?: 'Query', event: { __typename?: 'Event', id: string, name: string, rounds: Array<{ __typename?: 'Round', id: string, number: number, matches: Array<{ __typename?: 'Match', id: string, winnerId?: string | null, draw: boolean, player1: { __typename?: 'Player', id: string, name: string, score: number }, player2?: { __typename?: 'Player', id: string, name: string, score: number } | null }> }> } };

export type EventsIndexQueryVariables = Exact<{ [key: string]: never; }>;


export type EventsIndexQuery = { __typename?: 'Query', events: { __typename?: 'EventConnection', nodes: Array<{ __typename?: 'Event', id: string, name: string }> } };

export const CreatePlayerButtonFragmentDoc = gql`
    fragment CreatePlayerButton on Event {
  id
}
    `;
export const CreateRoundButtonFragmentDoc = gql`
    fragment CreateRoundButton on Event {
  id
}
    `;
export const EventNavFragmentDoc = gql`
    fragment EventNav on Event {
  id
}
    `;
export const EventLayoutFragmentDoc = gql`
    fragment EventLayout on Event {
  name
  ...EventNav
}
    ${EventNavFragmentDoc}`;
export const EventListItemFragmentDoc = gql`
    fragment EventListItem on Event {
  id
  name
}
    `;
export const EventListFragmentDoc = gql`
    fragment EventList on EventConnection {
  nodes {
    id
    ...EventListItem
  }
}
    ${EventListItemFragmentDoc}`;
export const EditPlayerDropdownItemFragmentDoc = gql`
    fragment EditPlayerDropdownItem on Player {
  id
  name
  paid
  dropped
}
    `;
export const PlayerActionsDropdownFragmentDoc = gql`
    fragment PlayerActionsDropdown on Player {
  id
  paid
  dropped
  ...EditPlayerDropdownItem
}
    ${EditPlayerDropdownItemFragmentDoc}`;
export const PlayerTableFragmentDoc = gql`
    fragment PlayerTable on Player {
  id
  name
  paid
  dropped
  winsCount
  drawsCount
  lossesCount
  score
  ...PlayerActionsDropdown
}
    ${PlayerActionsDropdownFragmentDoc}`;
export const RoundMatchListItemFragmentDoc = gql`
    fragment RoundMatchListItem on Match {
  id
  player1 {
    id
    name
  }
  player2 {
    id
    name
  }
  winnerId
  draw
}
    `;
export const RoundListFragmentDoc = gql`
    fragment RoundList on Event {
  rounds(orderBy: NUMBER, orderByDirection: DESC) {
    id
    number
    matches {
      id
      ...RoundMatchListItem
    }
  }
}
    ${RoundMatchListItemFragmentDoc}`;
export const RoundModalPlayerFragmentDoc = gql`
    fragment RoundModalPlayer on Player {
  id
  name
}
    `;
export const SlipEventFragmentDoc = gql`
    fragment SlipEvent on Event {
  id
  name
}
    `;
export const SlipRoundFragmentDoc = gql`
    fragment SlipRound on Round {
  id
  number
}
    `;
export const SlipMatchFragmentDoc = gql`
    fragment SlipMatch on Match {
  id
  player1 {
    id
    name
    score
  }
  player2 {
    id
    name
    score
  }
  winnerId
  draw
}
    `;
export const ErrorsFragmentDoc = gql`
    fragment Errors on Error {
  attribute
  message(full: true)
}
    `;
export const CreateEventDocument = gql`
    mutation CreateEvent($input: EventInput!) {
  eventCreate(input: $input) {
    event {
      id
      name
    }
    errors {
      ...Errors
    }
  }
}
    ${ErrorsFragmentDoc}`;
export type CreateEventMutationFn = Apollo.MutationFunction<CreateEventMutation, CreateEventMutationVariables>;

/**
 * __useCreateEventMutation__
 *
 * To run a mutation, you first call `useCreateEventMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateEventMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createEventMutation, { data, loading, error }] = useCreateEventMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateEventMutation(baseOptions?: Apollo.MutationHookOptions<CreateEventMutation, CreateEventMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateEventMutation, CreateEventMutationVariables>(CreateEventDocument, options);
      }
export type CreateEventMutationHookResult = ReturnType<typeof useCreateEventMutation>;
export type CreateEventMutationResult = Apollo.MutationResult<CreateEventMutation>;
export type CreateEventMutationOptions = Apollo.BaseMutationOptions<CreateEventMutation, CreateEventMutationVariables>;
export const CreatePlayerDocument = gql`
    mutation CreatePlayer($eventID: ID!, $input: PlayerInput!) {
  playerCreate(eventId: $eventID, input: $input) {
    player {
      id
    }
    errors {
      ...Errors
    }
  }
}
    ${ErrorsFragmentDoc}`;
export type CreatePlayerMutationFn = Apollo.MutationFunction<CreatePlayerMutation, CreatePlayerMutationVariables>;

/**
 * __useCreatePlayerMutation__
 *
 * To run a mutation, you first call `useCreatePlayerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePlayerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPlayerMutation, { data, loading, error }] = useCreatePlayerMutation({
 *   variables: {
 *      eventID: // value for 'eventID'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreatePlayerMutation(baseOptions?: Apollo.MutationHookOptions<CreatePlayerMutation, CreatePlayerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreatePlayerMutation, CreatePlayerMutationVariables>(CreatePlayerDocument, options);
      }
export type CreatePlayerMutationHookResult = ReturnType<typeof useCreatePlayerMutation>;
export type CreatePlayerMutationResult = Apollo.MutationResult<CreatePlayerMutation>;
export type CreatePlayerMutationOptions = Apollo.BaseMutationOptions<CreatePlayerMutation, CreatePlayerMutationVariables>;
export const PlayersForRoundCreateDocument = gql`
    query PlayersForRoundCreate($id: ID!) {
  event(id: $id) {
    id
    players(activeOnly: true) {
      nodes {
        id
        ...RoundModalPlayer
      }
    }
  }
}
    ${RoundModalPlayerFragmentDoc}`;

/**
 * __usePlayersForRoundCreateQuery__
 *
 * To run a query within a React component, call `usePlayersForRoundCreateQuery` and pass it any options that fit your needs.
 * When your component renders, `usePlayersForRoundCreateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePlayersForRoundCreateQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePlayersForRoundCreateQuery(baseOptions: Apollo.QueryHookOptions<PlayersForRoundCreateQuery, PlayersForRoundCreateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PlayersForRoundCreateQuery, PlayersForRoundCreateQueryVariables>(PlayersForRoundCreateDocument, options);
      }
export function usePlayersForRoundCreateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PlayersForRoundCreateQuery, PlayersForRoundCreateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PlayersForRoundCreateQuery, PlayersForRoundCreateQueryVariables>(PlayersForRoundCreateDocument, options);
        }
export type PlayersForRoundCreateQueryHookResult = ReturnType<typeof usePlayersForRoundCreateQuery>;
export type PlayersForRoundCreateLazyQueryHookResult = ReturnType<typeof usePlayersForRoundCreateLazyQuery>;
export type PlayersForRoundCreateQueryResult = Apollo.QueryResult<PlayersForRoundCreateQuery, PlayersForRoundCreateQueryVariables>;
export const CreateRoundDocument = gql`
    mutation CreateRound($eventId: ID!, $input: RoundCreateInput!) {
  roundCreate(eventId: $eventId, input: $input) {
    round {
      id
    }
    errors {
      ...Errors
    }
  }
}
    ${ErrorsFragmentDoc}`;
export type CreateRoundMutationFn = Apollo.MutationFunction<CreateRoundMutation, CreateRoundMutationVariables>;

/**
 * __useCreateRoundMutation__
 *
 * To run a mutation, you first call `useCreateRoundMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateRoundMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createRoundMutation, { data, loading, error }] = useCreateRoundMutation({
 *   variables: {
 *      eventId: // value for 'eventId'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateRoundMutation(baseOptions?: Apollo.MutationHookOptions<CreateRoundMutation, CreateRoundMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateRoundMutation, CreateRoundMutationVariables>(CreateRoundDocument, options);
      }
export type CreateRoundMutationHookResult = ReturnType<typeof useCreateRoundMutation>;
export type CreateRoundMutationResult = Apollo.MutationResult<CreateRoundMutation>;
export type CreateRoundMutationOptions = Apollo.BaseMutationOptions<CreateRoundMutation, CreateRoundMutationVariables>;
export const EditPlayerDocument = gql`
    mutation EditPlayer($id: ID!, $input: PlayerInput!) {
  playerUpdate(id: $id, input: $input) {
    player {
      id
      ...EditPlayerDropdownItem
    }
    errors {
      ...Errors
    }
  }
}
    ${EditPlayerDropdownItemFragmentDoc}
${ErrorsFragmentDoc}`;
export type EditPlayerMutationFn = Apollo.MutationFunction<EditPlayerMutation, EditPlayerMutationVariables>;

/**
 * __useEditPlayerMutation__
 *
 * To run a mutation, you first call `useEditPlayerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditPlayerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editPlayerMutation, { data, loading, error }] = useEditPlayerMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useEditPlayerMutation(baseOptions?: Apollo.MutationHookOptions<EditPlayerMutation, EditPlayerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EditPlayerMutation, EditPlayerMutationVariables>(EditPlayerDocument, options);
      }
export type EditPlayerMutationHookResult = ReturnType<typeof useEditPlayerMutation>;
export type EditPlayerMutationResult = Apollo.MutationResult<EditPlayerMutation>;
export type EditPlayerMutationOptions = Apollo.BaseMutationOptions<EditPlayerMutation, EditPlayerMutationVariables>;
export const PlayerActionsUpdateDocument = gql`
    mutation PlayerActionsUpdate($id: ID!, $input: PlayerInput!) {
  playerUpdate(id: $id, input: $input) {
    player {
      id
      ...PlayerActionsDropdown
    }
    errors {
      attribute
      message
    }
  }
}
    ${PlayerActionsDropdownFragmentDoc}`;
export type PlayerActionsUpdateMutationFn = Apollo.MutationFunction<PlayerActionsUpdateMutation, PlayerActionsUpdateMutationVariables>;

/**
 * __usePlayerActionsUpdateMutation__
 *
 * To run a mutation, you first call `usePlayerActionsUpdateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePlayerActionsUpdateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [playerActionsUpdateMutation, { data, loading, error }] = usePlayerActionsUpdateMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function usePlayerActionsUpdateMutation(baseOptions?: Apollo.MutationHookOptions<PlayerActionsUpdateMutation, PlayerActionsUpdateMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PlayerActionsUpdateMutation, PlayerActionsUpdateMutationVariables>(PlayerActionsUpdateDocument, options);
      }
export type PlayerActionsUpdateMutationHookResult = ReturnType<typeof usePlayerActionsUpdateMutation>;
export type PlayerActionsUpdateMutationResult = Apollo.MutationResult<PlayerActionsUpdateMutation>;
export type PlayerActionsUpdateMutationOptions = Apollo.BaseMutationOptions<PlayerActionsUpdateMutation, PlayerActionsUpdateMutationVariables>;
export const PlayerActionsDeleteDocument = gql`
    mutation PlayerActionsDelete($id: ID!) {
  playerDelete(id: $id) {
    success
    errors {
      attribute
      message
    }
  }
}
    `;
export type PlayerActionsDeleteMutationFn = Apollo.MutationFunction<PlayerActionsDeleteMutation, PlayerActionsDeleteMutationVariables>;

/**
 * __usePlayerActionsDeleteMutation__
 *
 * To run a mutation, you first call `usePlayerActionsDeleteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePlayerActionsDeleteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [playerActionsDeleteMutation, { data, loading, error }] = usePlayerActionsDeleteMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePlayerActionsDeleteMutation(baseOptions?: Apollo.MutationHookOptions<PlayerActionsDeleteMutation, PlayerActionsDeleteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PlayerActionsDeleteMutation, PlayerActionsDeleteMutationVariables>(PlayerActionsDeleteDocument, options);
      }
export type PlayerActionsDeleteMutationHookResult = ReturnType<typeof usePlayerActionsDeleteMutation>;
export type PlayerActionsDeleteMutationResult = Apollo.MutationResult<PlayerActionsDeleteMutation>;
export type PlayerActionsDeleteMutationOptions = Apollo.BaseMutationOptions<PlayerActionsDeleteMutation, PlayerActionsDeleteMutationVariables>;
export const GeneratePairingsForRoundDocument = gql`
    mutation GeneratePairingsForRound($eventId: ID!, $excludePlayerIds: [ID!]) {
  eventGeneratePairings(eventId: $eventId, excludePlayerIds: $excludePlayerIds) {
    pairings {
      player1 {
        ...RoundModalPlayer
      }
      player2 {
        ...RoundModalPlayer
      }
    }
  }
}
    ${RoundModalPlayerFragmentDoc}`;
export type GeneratePairingsForRoundMutationFn = Apollo.MutationFunction<GeneratePairingsForRoundMutation, GeneratePairingsForRoundMutationVariables>;

/**
 * __useGeneratePairingsForRoundMutation__
 *
 * To run a mutation, you first call `useGeneratePairingsForRoundMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGeneratePairingsForRoundMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [generatePairingsForRoundMutation, { data, loading, error }] = useGeneratePairingsForRoundMutation({
 *   variables: {
 *      eventId: // value for 'eventId'
 *      excludePlayerIds: // value for 'excludePlayerIds'
 *   },
 * });
 */
export function useGeneratePairingsForRoundMutation(baseOptions?: Apollo.MutationHookOptions<GeneratePairingsForRoundMutation, GeneratePairingsForRoundMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<GeneratePairingsForRoundMutation, GeneratePairingsForRoundMutationVariables>(GeneratePairingsForRoundDocument, options);
      }
export type GeneratePairingsForRoundMutationHookResult = ReturnType<typeof useGeneratePairingsForRoundMutation>;
export type GeneratePairingsForRoundMutationResult = Apollo.MutationResult<GeneratePairingsForRoundMutation>;
export type GeneratePairingsForRoundMutationOptions = Apollo.BaseMutationOptions<GeneratePairingsForRoundMutation, GeneratePairingsForRoundMutationVariables>;
export const EventShowDocument = gql`
    query EventShow($id: ID!) {
  event(id: $id) {
    id
    name
    ...EventLayout
  }
}
    ${EventLayoutFragmentDoc}`;

/**
 * __useEventShowQuery__
 *
 * To run a query within a React component, call `useEventShowQuery` and pass it any options that fit your needs.
 * When your component renders, `useEventShowQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEventShowQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useEventShowQuery(baseOptions: Apollo.QueryHookOptions<EventShowQuery, EventShowQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EventShowQuery, EventShowQueryVariables>(EventShowDocument, options);
      }
export function useEventShowLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventShowQuery, EventShowQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EventShowQuery, EventShowQueryVariables>(EventShowDocument, options);
        }
export type EventShowQueryHookResult = ReturnType<typeof useEventShowQuery>;
export type EventShowLazyQueryHookResult = ReturnType<typeof useEventShowLazyQuery>;
export type EventShowQueryResult = Apollo.QueryResult<EventShowQuery, EventShowQueryVariables>;
export const EventMatchesDocument = gql`
    query EventMatches($id: ID!) {
  event(id: $id) {
    id
    name
    ...EventLayout
    ...CreateRoundButton
    ...RoundList
    players {
      totalCount
    }
  }
}
    ${EventLayoutFragmentDoc}
${CreateRoundButtonFragmentDoc}
${RoundListFragmentDoc}`;

/**
 * __useEventMatchesQuery__
 *
 * To run a query within a React component, call `useEventMatchesQuery` and pass it any options that fit your needs.
 * When your component renders, `useEventMatchesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEventMatchesQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useEventMatchesQuery(baseOptions: Apollo.QueryHookOptions<EventMatchesQuery, EventMatchesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EventMatchesQuery, EventMatchesQueryVariables>(EventMatchesDocument, options);
      }
export function useEventMatchesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventMatchesQuery, EventMatchesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EventMatchesQuery, EventMatchesQueryVariables>(EventMatchesDocument, options);
        }
export type EventMatchesQueryHookResult = ReturnType<typeof useEventMatchesQuery>;
export type EventMatchesLazyQueryHookResult = ReturnType<typeof useEventMatchesLazyQuery>;
export type EventMatchesQueryResult = Apollo.QueryResult<EventMatchesQuery, EventMatchesQueryVariables>;
export const EventPlayersDocument = gql`
    query EventPlayers($id: ID!, $orderBy: EventPlayersOrderBy, $orderByDirection: OrderByDirection) {
  event(id: $id) {
    id
    name
    ...EventLayout
    ...CreatePlayerButton
    players(deleted: false, orderBy: $orderBy, orderByDirection: $orderByDirection) {
      nodes {
        ...PlayerTable
      }
    }
  }
}
    ${EventLayoutFragmentDoc}
${CreatePlayerButtonFragmentDoc}
${PlayerTableFragmentDoc}`;

/**
 * __useEventPlayersQuery__
 *
 * To run a query within a React component, call `useEventPlayersQuery` and pass it any options that fit your needs.
 * When your component renders, `useEventPlayersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEventPlayersQuery({
 *   variables: {
 *      id: // value for 'id'
 *      orderBy: // value for 'orderBy'
 *      orderByDirection: // value for 'orderByDirection'
 *   },
 * });
 */
export function useEventPlayersQuery(baseOptions: Apollo.QueryHookOptions<EventPlayersQuery, EventPlayersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EventPlayersQuery, EventPlayersQueryVariables>(EventPlayersDocument, options);
      }
export function useEventPlayersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventPlayersQuery, EventPlayersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EventPlayersQuery, EventPlayersQueryVariables>(EventPlayersDocument, options);
        }
export type EventPlayersQueryHookResult = ReturnType<typeof useEventPlayersQuery>;
export type EventPlayersLazyQueryHookResult = ReturnType<typeof useEventPlayersLazyQuery>;
export type EventPlayersQueryResult = Apollo.QueryResult<EventPlayersQuery, EventPlayersQueryVariables>;
export const EventSlipsDocument = gql`
    query EventSlips($id: ID!) {
  event(id: $id) {
    id
    name
    ...EventLayout
    ...SlipEvent
    rounds {
      id
      ...SlipRound
      matches {
        ...SlipMatch
      }
    }
  }
}
    ${EventLayoutFragmentDoc}
${SlipEventFragmentDoc}
${SlipRoundFragmentDoc}
${SlipMatchFragmentDoc}`;

/**
 * __useEventSlipsQuery__
 *
 * To run a query within a React component, call `useEventSlipsQuery` and pass it any options that fit your needs.
 * When your component renders, `useEventSlipsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEventSlipsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useEventSlipsQuery(baseOptions: Apollo.QueryHookOptions<EventSlipsQuery, EventSlipsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EventSlipsQuery, EventSlipsQueryVariables>(EventSlipsDocument, options);
      }
export function useEventSlipsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventSlipsQuery, EventSlipsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EventSlipsQuery, EventSlipsQueryVariables>(EventSlipsDocument, options);
        }
export type EventSlipsQueryHookResult = ReturnType<typeof useEventSlipsQuery>;
export type EventSlipsLazyQueryHookResult = ReturnType<typeof useEventSlipsLazyQuery>;
export type EventSlipsQueryResult = Apollo.QueryResult<EventSlipsQuery, EventSlipsQueryVariables>;
export const EventsIndexDocument = gql`
    query EventsIndex {
  events {
    ...EventList
  }
}
    ${EventListFragmentDoc}`;

/**
 * __useEventsIndexQuery__
 *
 * To run a query within a React component, call `useEventsIndexQuery` and pass it any options that fit your needs.
 * When your component renders, `useEventsIndexQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEventsIndexQuery({
 *   variables: {
 *   },
 * });
 */
export function useEventsIndexQuery(baseOptions?: Apollo.QueryHookOptions<EventsIndexQuery, EventsIndexQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EventsIndexQuery, EventsIndexQueryVariables>(EventsIndexDocument, options);
      }
export function useEventsIndexLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventsIndexQuery, EventsIndexQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EventsIndexQuery, EventsIndexQueryVariables>(EventsIndexDocument, options);
        }
export type EventsIndexQueryHookResult = ReturnType<typeof useEventsIndexQuery>;
export type EventsIndexLazyQueryHookResult = ReturnType<typeof useEventsIndexLazyQuery>;
export type EventsIndexQueryResult = Apollo.QueryResult<EventsIndexQuery, EventsIndexQueryVariables>;

      export interface PossibleTypesResultData {
        possibleTypes: {
          [key: string]: string[]
        }
      }
      const result: PossibleTypesResultData = {
  "possibleTypes": {}
};
      export default result;
    
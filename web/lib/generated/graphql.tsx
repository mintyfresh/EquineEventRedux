import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  ISO8601DateTime: any;
};

export enum DeletedFilter {
  /** Returns both deleted and non-deleted records */
  All = 'ALL',
  /** Returns only deleted records */
  Deleted = 'DELETED',
  /** Returns only non-deleted records */
  NonDeleted = 'NON_DELETED'
}

export type Error = {
  __typename?: 'Error';
  attribute: Scalars['String'];
  message: Scalars['String'];
};


export type ErrorMessageArgs = {
  full?: InputMaybe<Scalars['Boolean']>;
};

export type Event = {
  __typename?: 'Event';
  createdAt: Scalars['ISO8601DateTime'];
  deleted: Scalars['Boolean'];
  deletedAt?: Maybe<Scalars['ISO8601DateTime']>;
  id: Scalars['ID'];
  name: Scalars['String'];
  players: PlayerConnection;
  rounds: Array<Round>;
};


export type EventPlayersArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  deleted?: InputMaybe<DeletedFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<EventPlayersOrderBy>;
  orderByDirection?: InputMaybe<OrderByDirection>;
};


export type EventRoundsArgs = {
  deleted?: InputMaybe<DeletedFilter>;
  orderBy?: InputMaybe<EventRoundsOrderBy>;
  orderByDirection?: InputMaybe<OrderByDirection>;
};

/** The connection type for Event. */
export type EventConnection = {
  __typename?: 'EventConnection';
  /** A list of edges. */
  edges: Array<EventEdge>;
  /** A list of nodes. */
  nodes: Array<Event>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated return type of EventCreate */
export type EventCreatePayload = {
  __typename?: 'EventCreatePayload';
  errors?: Maybe<Array<Error>>;
  event?: Maybe<Event>;
};

/** Autogenerated return type of EventDelete */
export type EventDeletePayload = {
  __typename?: 'EventDeletePayload';
  errors?: Maybe<Array<Error>>;
  success?: Maybe<Scalars['Boolean']>;
};

/** An edge in a connection. */
export type EventEdge = {
  __typename?: 'EventEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Event>;
};

/** Autogenerated return type of EventGeneratePairings */
export type EventGeneratePairingsPayload = {
  __typename?: 'EventGeneratePairingsPayload';
  pairings: Array<Pairing>;
};

export type EventInput = {
  name?: InputMaybe<Scalars['String']>;
};

export enum EventPlayersOrderBy {
  DrawsCount = 'DRAWS_COUNT',
  LossesCount = 'LOSSES_COUNT',
  Name = 'NAME',
  Score = 'SCORE',
  WinsCount = 'WINS_COUNT'
}

/** Autogenerated return type of EventRestore */
export type EventRestorePayload = {
  __typename?: 'EventRestorePayload';
  errors?: Maybe<Array<Error>>;
  event?: Maybe<Event>;
};

export enum EventRoundsOrderBy {
  Number = 'NUMBER'
}

/** Autogenerated return type of EventUpdate */
export type EventUpdatePayload = {
  __typename?: 'EventUpdatePayload';
  errors?: Maybe<Array<Error>>;
  event?: Maybe<Event>;
};

export type Match = {
  __typename?: 'Match';
  draw: Scalars['Boolean'];
  id: Scalars['ID'];
  player1: Player;
  player1Id: Scalars['ID'];
  player2?: Maybe<Player>;
  player2Id?: Maybe<Scalars['ID']>;
  roundId: Scalars['ID'];
  table: Scalars['Int'];
  winnerId?: Maybe<Scalars['ID']>;
};

export type MatchInput = {
  _destroy?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['ID']>;
  player1Id: Scalars['ID'];
  player2Id?: InputMaybe<Scalars['ID']>;
  table: Scalars['Int'];
};

export type MatchUpdateInput = {
  draw?: InputMaybe<Scalars['Boolean']>;
  winnerId?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of MatchUpdate */
export type MatchUpdatePayload = {
  __typename?: 'MatchUpdatePayload';
  errors?: Maybe<Array<Error>>;
  match?: Maybe<Match>;
};

export type Mutation = {
  __typename?: 'Mutation';
  /** Creates a new Event */
  eventCreate?: Maybe<EventCreatePayload>;
  /** Deletes an existing Event by ID */
  eventDelete?: Maybe<EventDeletePayload>;
  /** Generates a possible list of pairings for a round. */
  eventGeneratePairings?: Maybe<EventGeneratePairingsPayload>;
  /** Restores a deleted Event by ID */
  eventRestore?: Maybe<EventRestorePayload>;
  /** Updates an existing Event by ID */
  eventUpdate?: Maybe<EventUpdatePayload>;
  /** Updates an existing Match by ID */
  matchUpdate?: Maybe<MatchUpdatePayload>;
  /** Creates a new Player */
  playerCreate?: Maybe<PlayerCreatePayload>;
  /** Deletes an existing Player by ID */
  playerDelete?: Maybe<PlayerDeletePayload>;
  /** Restores a deleted Player by ID */
  playerRestore?: Maybe<PlayerRestorePayload>;
  /** Updates an existing Player by ID */
  playerUpdate?: Maybe<PlayerUpdatePayload>;
  /** Creates a new Round */
  roundCreate?: Maybe<RoundCreatePayload>;
  /** Deletes an existing Round by ID */
  roundDelete?: Maybe<RoundDeletePayload>;
  /** Restores a deleted Round by ID */
  roundRestore?: Maybe<RoundRestorePayload>;
  /** Updates an existing Round by ID */
  roundUpdate?: Maybe<RoundUpdatePayload>;
};


export type MutationEventCreateArgs = {
  input: EventInput;
};


export type MutationEventDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationEventGeneratePairingsArgs = {
  eventId: Scalars['ID'];
  playerIds: Array<Scalars['ID']>;
};


export type MutationEventRestoreArgs = {
  id: Scalars['ID'];
};


export type MutationEventUpdateArgs = {
  id: Scalars['ID'];
  input: EventInput;
};


export type MutationMatchUpdateArgs = {
  id: Scalars['ID'];
  input: MatchUpdateInput;
};


export type MutationPlayerCreateArgs = {
  eventId: Scalars['ID'];
  input: PlayerInput;
};


export type MutationPlayerDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationPlayerRestoreArgs = {
  id: Scalars['ID'];
};


export type MutationPlayerUpdateArgs = {
  id: Scalars['ID'];
  input: PlayerInput;
};


export type MutationRoundCreateArgs = {
  eventId: Scalars['ID'];
  input: RoundInput;
};


export type MutationRoundDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationRoundRestoreArgs = {
  id: Scalars['ID'];
};


export type MutationRoundUpdateArgs = {
  id: Scalars['ID'];
  input: RoundInput;
};

export enum OrderByDirection {
  /** Indicates that the results should be sorted in ascending order, from smallest to largest. */
  Asc = 'ASC',
  /** Indicates that the results should be sorted in descending order, from largest to smallest. */
  Desc = 'DESC'
}

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']>;
};

export type Pairing = {
  __typename?: 'Pairing';
  player1: Player;
  player2?: Maybe<Player>;
};

export type Player = {
  __typename?: 'Player';
  deleted: Scalars['Boolean'];
  deletedAt?: Maybe<Scalars['ISO8601DateTime']>;
  drawsCount: Scalars['Int'];
  dropped: Scalars['Boolean'];
  eventId: Scalars['ID'];
  id: Scalars['ID'];
  lossesCount: Scalars['Int'];
  name: Scalars['String'];
  opponentWinRate: Scalars['Float'];
  paid: Scalars['Boolean'];
  score: Scalars['Int'];
  winsCount: Scalars['Int'];
};

/** The connection type for Player. */
export type PlayerConnection = {
  __typename?: 'PlayerConnection';
  /** A list of edges. */
  edges: Array<PlayerEdge>;
  /** A list of nodes. */
  nodes: Array<Player>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** Autogenerated return type of PlayerCreate */
export type PlayerCreatePayload = {
  __typename?: 'PlayerCreatePayload';
  errors?: Maybe<Array<Error>>;
  /** The Event that the Player was added to */
  event?: Maybe<Event>;
  player?: Maybe<Player>;
};

/** Autogenerated return type of PlayerDelete */
export type PlayerDeletePayload = {
  __typename?: 'PlayerDeletePayload';
  errors?: Maybe<Array<Error>>;
  success?: Maybe<Scalars['Boolean']>;
};

/** An edge in a connection. */
export type PlayerEdge = {
  __typename?: 'PlayerEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Player>;
};

export type PlayerInput = {
  dropped?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  paid?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of PlayerRestore */
export type PlayerRestorePayload = {
  __typename?: 'PlayerRestorePayload';
  errors?: Maybe<Array<Error>>;
  player?: Maybe<Player>;
};

/** Autogenerated return type of PlayerUpdate */
export type PlayerUpdatePayload = {
  __typename?: 'PlayerUpdatePayload';
  errors?: Maybe<Array<Error>>;
  player?: Maybe<Player>;
};

export type Query = {
  __typename?: 'Query';
  /** Finds a Event by ID */
  event: Event;
  /** Finds a list of Event objects */
  events: EventConnection;
  /** Finds a Match by ID */
  match: Match;
  /** Finds a Player by ID */
  player: Player;
  /** Finds a Round by ID */
  round: Round;
};


export type QueryEventArgs = {
  id: Scalars['ID'];
};


export type QueryEventsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  deleted?: InputMaybe<DeletedFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueryMatchArgs = {
  id: Scalars['ID'];
};


export type QueryPlayerArgs = {
  id: Scalars['ID'];
};


export type QueryRoundArgs = {
  id: Scalars['ID'];
};

export type Round = {
  __typename?: 'Round';
  eventId: Scalars['ID'];
  id: Scalars['ID'];
  matches: Array<Match>;
  number: Scalars['Int'];
  players: Array<Player>;
  unpairedPlayers: Array<Player>;
};


export type RoundPlayersArgs = {
  deleted?: InputMaybe<DeletedFilter>;
};


export type RoundUnpairedPlayersArgs = {
  deleted?: InputMaybe<DeletedFilter>;
};

/** Autogenerated return type of RoundCreate */
export type RoundCreatePayload = {
  __typename?: 'RoundCreatePayload';
  errors?: Maybe<Array<Error>>;
  /** The Event that the Round was added to */
  event?: Maybe<Event>;
  round?: Maybe<Round>;
};

/** Autogenerated return type of RoundDelete */
export type RoundDeletePayload = {
  __typename?: 'RoundDeletePayload';
  errors?: Maybe<Array<Error>>;
  success?: Maybe<Scalars['Boolean']>;
};

export type RoundInput = {
  matches?: InputMaybe<Array<MatchInput>>;
};

/** Autogenerated return type of RoundRestore */
export type RoundRestorePayload = {
  __typename?: 'RoundRestorePayload';
  errors?: Maybe<Array<Error>>;
  round?: Maybe<Round>;
};

/** Autogenerated return type of RoundUpdate */
export type RoundUpdatePayload = {
  __typename?: 'RoundUpdatePayload';
  errors?: Maybe<Array<Error>>;
  round?: Maybe<Round>;
};

export type CreateEventMutationVariables = Exact<{
  input: EventInput;
}>;


export type CreateEventMutation = { __typename?: 'Mutation', eventCreate?: { __typename?: 'EventCreatePayload', event?: { __typename?: 'Event', id: string, name: string } | null, errors?: Array<{ __typename?: 'Error', attribute: string, message: string }> | null } | null };

export type CreatePlayerMutationVariables = Exact<{
  eventID: Scalars['ID'];
  input: PlayerInput;
}>;


export type CreatePlayerMutation = { __typename?: 'Mutation', playerCreate?: { __typename?: 'PlayerCreatePayload', player?: { __typename?: 'Player', id: string } | null, errors?: Array<{ __typename?: 'Error', attribute: string, message: string }> | null } | null };

export type CreatePlayerButtonFragment = { __typename?: 'Event', id: string };

export type CreateRoundButtonFragment = { __typename?: 'Event', id: string };

export type PlayersForRoundCreateQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type PlayersForRoundCreateQuery = { __typename?: 'Query', event: { __typename?: 'Event', id: string, players: { __typename?: 'PlayerConnection', nodes: Array<{ __typename?: 'Player', id: string, name: string }> } } };

export type CreateRoundMutationVariables = Exact<{
  eventId: Scalars['ID'];
  input: RoundInput;
}>;


export type CreateRoundMutation = { __typename?: 'Mutation', roundCreate?: { __typename?: 'RoundCreatePayload', round?: { __typename?: 'Round', id: string } | null, errors?: Array<{ __typename?: 'Error', attribute: string, message: string }> | null } | null };

export type EventLayoutFragment = { __typename?: 'Event', name: string, id: string };

export type EventListFragment = { __typename?: 'EventConnection', nodes: Array<{ __typename?: 'Event', id: string, name: string, deleted: boolean }> };

export type EventListItemFragment = { __typename?: 'Event', id: string, name: string, deleted: boolean };

export type DeleteEventMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DeleteEventMutation = { __typename?: 'Mutation', eventDelete?: { __typename?: 'EventDeletePayload', success?: boolean | null } | null };

export type RestoreEventMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type RestoreEventMutation = { __typename?: 'Mutation', eventRestore?: { __typename?: 'EventRestorePayload', event?: { __typename?: 'Event', id: string, name: string, deleted: boolean } | null } | null };

export type EventNavFragment = { __typename?: 'Event', id: string };

export type MatchFormInputPlayerFragment = { __typename?: 'Player', id: string, name: string };

export type PlayerTableFragment = { __typename?: 'Player', id: string, name: string, winsCount: number, drawsCount: number, lossesCount: number, score: number, opponentWinRate: number, paid: boolean, dropped: boolean, deleted: boolean };

export type EditPlayerDropdownItemFragment = { __typename?: 'Player', id: string, name: string, paid: boolean, dropped: boolean };

export type EditPlayerMutationVariables = Exact<{
  id: Scalars['ID'];
  input: PlayerInput;
}>;


export type EditPlayerMutation = { __typename?: 'Mutation', playerUpdate?: { __typename?: 'PlayerUpdatePayload', player?: { __typename?: 'Player', id: string, name: string, paid: boolean, dropped: boolean } | null, errors?: Array<{ __typename?: 'Error', attribute: string, message: string }> | null } | null };

export type PlayerActionsDropdownFragment = { __typename?: 'Player', id: string, paid: boolean, dropped: boolean, name: string };

export type PlayerActionsUpdateMutationVariables = Exact<{
  id: Scalars['ID'];
  input: PlayerInput;
}>;


export type PlayerActionsUpdateMutation = { __typename?: 'Mutation', playerUpdate?: { __typename?: 'PlayerUpdatePayload', player?: { __typename?: 'Player', id: string, paid: boolean, dropped: boolean, name: string } | null, errors?: Array<{ __typename?: 'Error', attribute: string, message: string }> | null } | null };

export type PlayerActionsDeleteMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type PlayerActionsDeleteMutation = { __typename?: 'Mutation', playerDelete?: { __typename?: 'PlayerDeletePayload', success?: boolean | null, errors?: Array<{ __typename?: 'Error', attribute: string, message: string }> | null } | null };

export type PlayerNameWithBadgesFragment = { __typename?: 'Player', id: string, name: string, paid: boolean, dropped: boolean, deleted: boolean };

export type RoundListItemFragment = { __typename?: 'Round', id: string, number: number, matches: Array<{ __typename?: 'Match', id: string, table: number, winnerId?: string | null, draw: boolean, player1: { __typename?: 'Player', id: string, name: string, paid: boolean, dropped: boolean, deleted: boolean }, player2?: { __typename?: 'Player', id: string, name: string, paid: boolean, dropped: boolean, deleted: boolean } | null }> };

export type EditRoundDropdownItemFragment = { __typename?: 'Round', id: string, number: number, matches: Array<{ __typename?: 'Match', id: string, table: number, player1: { __typename?: 'Player', id: string, name: string }, player2?: { __typename?: 'Player', id: string, name: string } | null }> };

export type PlayersForEditRoundQueryVariables = Exact<{
  roundID: Scalars['ID'];
}>;


export type PlayersForEditRoundQuery = { __typename?: 'Query', round: { __typename?: 'Round', id: string, players: Array<{ __typename?: 'Player', id: string, name: string }>, unpairedPlayers: Array<{ __typename?: 'Player', id: string, name: string }> } };

export type UpdateRoundMutationVariables = Exact<{
  roundID: Scalars['ID'];
  roundInput: RoundInput;
}>;


export type UpdateRoundMutation = { __typename?: 'Mutation', roundUpdate?: { __typename?: 'RoundUpdatePayload', round?: { __typename?: 'Round', id: string, number: number, matches: Array<{ __typename?: 'Match', id: string, table: number, player1: { __typename?: 'Player', id: string, name: string }, player2?: { __typename?: 'Player', id: string, name: string } | null }> } | null, errors?: Array<{ __typename?: 'Error', attribute: string, message: string }> | null } | null };

export type RoundControlsDropdownFragment = { __typename?: 'Round', id: string, number: number, matches: Array<{ __typename?: 'Match', id: string, table: number, player1: { __typename?: 'Player', id: string, name: string }, player2?: { __typename?: 'Player', id: string, name: string } | null }> };

export type DeleteRoundMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DeleteRoundMutation = { __typename?: 'Mutation', roundDelete?: { __typename?: 'RoundDeletePayload', success?: boolean | null, errors?: Array<{ __typename?: 'Error', attribute: string, message: string }> | null } | null };

export type SetMatchResolutionMutationVariables = Exact<{
  id: Scalars['ID'];
  winnerId?: InputMaybe<Scalars['ID']>;
  draw: Scalars['Boolean'];
}>;


export type SetMatchResolutionMutation = { __typename?: 'Mutation', matchUpdate?: { __typename?: 'MatchUpdatePayload', match?: { __typename?: 'Match', id: string, winnerId?: string | null, draw: boolean } | null, errors?: Array<{ __typename?: 'Error', attribute: string, message: string }> | null } | null };

export type RoundMatchListItemFragment = { __typename?: 'Match', id: string, winnerId?: string | null, draw: boolean, table: number, player1: { __typename?: 'Player', id: string, name: string, paid: boolean, dropped: boolean, deleted: boolean }, player2?: { __typename?: 'Player', id: string, name: string, paid: boolean, dropped: boolean, deleted: boolean } | null };

export type GeneratePairingsMutationVariables = Exact<{
  eventId: Scalars['ID'];
  playerIds: Array<Scalars['ID']> | Scalars['ID'];
}>;


export type GeneratePairingsMutation = { __typename?: 'Mutation', eventGeneratePairings?: { __typename?: 'EventGeneratePairingsPayload', pairings: Array<{ __typename?: 'Pairing', player1: { __typename?: 'Player', id: string, name: string }, player2?: { __typename?: 'Player', id: string, name: string } | null }> } | null };

export type SlipEventFragment = { __typename?: 'Event', id: string, name: string };

export type SlipRoundFragment = { __typename?: 'Round', id: string, number: number };

export type SlipMatchFragment = { __typename?: 'Match', id: string, winnerId?: string | null, draw: boolean, table: number, player1: { __typename?: 'Player', id: string, name: string, score: number }, player2?: { __typename?: 'Player', id: string, name: string, score: number } | null };

export type ErrorsFragment = { __typename?: 'Error', attribute: string, message: string };

export type EventShowQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type EventShowQuery = { __typename?: 'Query', event: { __typename?: 'Event', id: string, name: string } };

export type EventMatchesQueryVariables = Exact<{
  id: Scalars['ID'];
  deleted?: InputMaybe<DeletedFilter>;
}>;


export type EventMatchesQuery = { __typename?: 'Query', event: { __typename?: 'Event', id: string, name: string, rounds: Array<{ __typename?: 'Round', id: string, number: number, matches: Array<{ __typename?: 'Match', id: string, table: number, winnerId?: string | null, draw: boolean, player1: { __typename?: 'Player', id: string, name: string, paid: boolean, dropped: boolean, deleted: boolean }, player2?: { __typename?: 'Player', id: string, name: string, paid: boolean, dropped: boolean, deleted: boolean } | null }> }>, players: { __typename?: 'PlayerConnection', totalCount: number } } };

export type EventPlayersQueryVariables = Exact<{
  id: Scalars['ID'];
  deleted?: InputMaybe<DeletedFilter>;
}>;


export type EventPlayersQuery = { __typename?: 'Query', event: { __typename?: 'Event', id: string, name: string, players: { __typename?: 'PlayerConnection', nodes: Array<{ __typename?: 'Player', id: string, name: string, winsCount: number, drawsCount: number, lossesCount: number, score: number, opponentWinRate: number, paid: boolean, dropped: boolean, deleted: boolean }> } } };

export type EventSlipsQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type EventSlipsQuery = { __typename?: 'Query', event: { __typename?: 'Event', id: string, name: string, rounds: Array<{ __typename?: 'Round', id: string, number: number, matches: Array<{ __typename?: 'Match', id: string, winnerId?: string | null, draw: boolean, table: number, player1: { __typename?: 'Player', id: string, name: string, score: number }, player2?: { __typename?: 'Player', id: string, name: string, score: number } | null }> }> } };

export type EventsIndexQueryVariables = Exact<{
  deleted?: InputMaybe<DeletedFilter>;
}>;


export type EventsIndexQuery = { __typename?: 'Query', events: { __typename?: 'EventConnection', nodes: Array<{ __typename?: 'Event', id: string, name: string, deleted: boolean }> } };

export const CreatePlayerButtonFragmentDoc = gql`
    fragment CreatePlayerButton on Event {
  id
}
    `;
export const CreateRoundButtonFragmentDoc = gql`
    fragment CreateRoundButton on Event {
  id
}
    `;
export const EventNavFragmentDoc = gql`
    fragment EventNav on Event {
  id
}
    `;
export const EventLayoutFragmentDoc = gql`
    fragment EventLayout on Event {
  name
  ...EventNav
}
    ${EventNavFragmentDoc}`;
export const EventListItemFragmentDoc = gql`
    fragment EventListItem on Event {
  id
  name
  deleted
}
    `;
export const EventListFragmentDoc = gql`
    fragment EventList on EventConnection {
  nodes {
    id
    ...EventListItem
  }
}
    ${EventListItemFragmentDoc}`;
export const PlayerNameWithBadgesFragmentDoc = gql`
    fragment PlayerNameWithBadges on Player {
  id
  name
  paid
  dropped
  deleted
}
    `;
export const EditPlayerDropdownItemFragmentDoc = gql`
    fragment EditPlayerDropdownItem on Player {
  id
  name
  paid
  dropped
}
    `;
export const PlayerActionsDropdownFragmentDoc = gql`
    fragment PlayerActionsDropdown on Player {
  id
  paid
  dropped
  ...EditPlayerDropdownItem
}
    ${EditPlayerDropdownItemFragmentDoc}`;
export const PlayerTableFragmentDoc = gql`
    fragment PlayerTable on Player {
  id
  name
  winsCount
  drawsCount
  lossesCount
  score
  opponentWinRate
  ...PlayerNameWithBadges
  ...PlayerActionsDropdown
}
    ${PlayerNameWithBadgesFragmentDoc}
${PlayerActionsDropdownFragmentDoc}`;
export const MatchFormInputPlayerFragmentDoc = gql`
    fragment MatchFormInputPlayer on Player {
  id
  name
}
    `;
export const EditRoundDropdownItemFragmentDoc = gql`
    fragment EditRoundDropdownItem on Round {
  id
  number
  matches {
    id
    table
    player1 {
      id
      ...MatchFormInputPlayer
    }
    player2 {
      id
      ...MatchFormInputPlayer
    }
  }
}
    ${MatchFormInputPlayerFragmentDoc}`;
export const RoundControlsDropdownFragmentDoc = gql`
    fragment RoundControlsDropdown on Round {
  id
  ...EditRoundDropdownItem
}
    ${EditRoundDropdownItemFragmentDoc}`;
export const RoundMatchListItemFragmentDoc = gql`
    fragment RoundMatchListItem on Match {
  id
  player1 {
    id
    ...PlayerNameWithBadges
  }
  player2 {
    id
    ...PlayerNameWithBadges
  }
  winnerId
  draw
  table
}
    ${PlayerNameWithBadgesFragmentDoc}`;
export const RoundListItemFragmentDoc = gql`
    fragment RoundListItem on Round {
  id
  number
  ...RoundControlsDropdown
  matches {
    id
    ...RoundMatchListItem
  }
}
    ${RoundControlsDropdownFragmentDoc}
${RoundMatchListItemFragmentDoc}`;
export const SlipEventFragmentDoc = gql`
    fragment SlipEvent on Event {
  id
  name
}
    `;
export const SlipRoundFragmentDoc = gql`
    fragment SlipRound on Round {
  id
  number
}
    `;
export const SlipMatchFragmentDoc = gql`
    fragment SlipMatch on Match {
  id
  player1 {
    id
    name
    score
  }
  player2 {
    id
    name
    score
  }
  winnerId
  draw
  table
}
    `;
export const ErrorsFragmentDoc = gql`
    fragment Errors on Error {
  attribute
  message(full: true)
}
    `;
export const CreateEventDocument = gql`
    mutation CreateEvent($input: EventInput!) {
  eventCreate(input: $input) {
    event {
      id
      name
    }
    errors {
      ...Errors
    }
  }
}
    ${ErrorsFragmentDoc}`;
export type CreateEventMutationFn = Apollo.MutationFunction<CreateEventMutation, CreateEventMutationVariables>;

/**
 * __useCreateEventMutation__
 *
 * To run a mutation, you first call `useCreateEventMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateEventMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createEventMutation, { data, loading, error }] = useCreateEventMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateEventMutation(baseOptions?: Apollo.MutationHookOptions<CreateEventMutation, CreateEventMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateEventMutation, CreateEventMutationVariables>(CreateEventDocument, options);
      }
export type CreateEventMutationHookResult = ReturnType<typeof useCreateEventMutation>;
export type CreateEventMutationResult = Apollo.MutationResult<CreateEventMutation>;
export type CreateEventMutationOptions = Apollo.BaseMutationOptions<CreateEventMutation, CreateEventMutationVariables>;
export const CreatePlayerDocument = gql`
    mutation CreatePlayer($eventID: ID!, $input: PlayerInput!) {
  playerCreate(eventId: $eventID, input: $input) {
    player {
      id
    }
    errors {
      ...Errors
    }
  }
}
    ${ErrorsFragmentDoc}`;
export type CreatePlayerMutationFn = Apollo.MutationFunction<CreatePlayerMutation, CreatePlayerMutationVariables>;

/**
 * __useCreatePlayerMutation__
 *
 * To run a mutation, you first call `useCreatePlayerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePlayerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPlayerMutation, { data, loading, error }] = useCreatePlayerMutation({
 *   variables: {
 *      eventID: // value for 'eventID'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreatePlayerMutation(baseOptions?: Apollo.MutationHookOptions<CreatePlayerMutation, CreatePlayerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreatePlayerMutation, CreatePlayerMutationVariables>(CreatePlayerDocument, options);
      }
export type CreatePlayerMutationHookResult = ReturnType<typeof useCreatePlayerMutation>;
export type CreatePlayerMutationResult = Apollo.MutationResult<CreatePlayerMutation>;
export type CreatePlayerMutationOptions = Apollo.BaseMutationOptions<CreatePlayerMutation, CreatePlayerMutationVariables>;
export const PlayersForRoundCreateDocument = gql`
    query PlayersForRoundCreate($id: ID!) {
  event(id: $id) {
    id
    players(activeOnly: true) {
      nodes {
        id
        ...MatchFormInputPlayer
      }
    }
  }
}
    ${MatchFormInputPlayerFragmentDoc}`;

/**
 * __usePlayersForRoundCreateQuery__
 *
 * To run a query within a React component, call `usePlayersForRoundCreateQuery` and pass it any options that fit your needs.
 * When your component renders, `usePlayersForRoundCreateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePlayersForRoundCreateQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePlayersForRoundCreateQuery(baseOptions: Apollo.QueryHookOptions<PlayersForRoundCreateQuery, PlayersForRoundCreateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PlayersForRoundCreateQuery, PlayersForRoundCreateQueryVariables>(PlayersForRoundCreateDocument, options);
      }
export function usePlayersForRoundCreateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PlayersForRoundCreateQuery, PlayersForRoundCreateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PlayersForRoundCreateQuery, PlayersForRoundCreateQueryVariables>(PlayersForRoundCreateDocument, options);
        }
export type PlayersForRoundCreateQueryHookResult = ReturnType<typeof usePlayersForRoundCreateQuery>;
export type PlayersForRoundCreateLazyQueryHookResult = ReturnType<typeof usePlayersForRoundCreateLazyQuery>;
export type PlayersForRoundCreateQueryResult = Apollo.QueryResult<PlayersForRoundCreateQuery, PlayersForRoundCreateQueryVariables>;
export const CreateRoundDocument = gql`
    mutation CreateRound($eventId: ID!, $input: RoundInput!) {
  roundCreate(eventId: $eventId, input: $input) {
    round {
      id
    }
    errors {
      ...Errors
    }
  }
}
    ${ErrorsFragmentDoc}`;
export type CreateRoundMutationFn = Apollo.MutationFunction<CreateRoundMutation, CreateRoundMutationVariables>;

/**
 * __useCreateRoundMutation__
 *
 * To run a mutation, you first call `useCreateRoundMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateRoundMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createRoundMutation, { data, loading, error }] = useCreateRoundMutation({
 *   variables: {
 *      eventId: // value for 'eventId'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateRoundMutation(baseOptions?: Apollo.MutationHookOptions<CreateRoundMutation, CreateRoundMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateRoundMutation, CreateRoundMutationVariables>(CreateRoundDocument, options);
      }
export type CreateRoundMutationHookResult = ReturnType<typeof useCreateRoundMutation>;
export type CreateRoundMutationResult = Apollo.MutationResult<CreateRoundMutation>;
export type CreateRoundMutationOptions = Apollo.BaseMutationOptions<CreateRoundMutation, CreateRoundMutationVariables>;
export const DeleteEventDocument = gql`
    mutation DeleteEvent($id: ID!) {
  eventDelete(id: $id) {
    success
  }
}
    `;
export type DeleteEventMutationFn = Apollo.MutationFunction<DeleteEventMutation, DeleteEventMutationVariables>;

/**
 * __useDeleteEventMutation__
 *
 * To run a mutation, you first call `useDeleteEventMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteEventMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteEventMutation, { data, loading, error }] = useDeleteEventMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteEventMutation(baseOptions?: Apollo.MutationHookOptions<DeleteEventMutation, DeleteEventMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteEventMutation, DeleteEventMutationVariables>(DeleteEventDocument, options);
      }
export type DeleteEventMutationHookResult = ReturnType<typeof useDeleteEventMutation>;
export type DeleteEventMutationResult = Apollo.MutationResult<DeleteEventMutation>;
export type DeleteEventMutationOptions = Apollo.BaseMutationOptions<DeleteEventMutation, DeleteEventMutationVariables>;
export const RestoreEventDocument = gql`
    mutation RestoreEvent($id: ID!) {
  eventRestore(id: $id) {
    event {
      id
      ...EventListItem
    }
  }
}
    ${EventListItemFragmentDoc}`;
export type RestoreEventMutationFn = Apollo.MutationFunction<RestoreEventMutation, RestoreEventMutationVariables>;

/**
 * __useRestoreEventMutation__
 *
 * To run a mutation, you first call `useRestoreEventMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRestoreEventMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [restoreEventMutation, { data, loading, error }] = useRestoreEventMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRestoreEventMutation(baseOptions?: Apollo.MutationHookOptions<RestoreEventMutation, RestoreEventMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RestoreEventMutation, RestoreEventMutationVariables>(RestoreEventDocument, options);
      }
export type RestoreEventMutationHookResult = ReturnType<typeof useRestoreEventMutation>;
export type RestoreEventMutationResult = Apollo.MutationResult<RestoreEventMutation>;
export type RestoreEventMutationOptions = Apollo.BaseMutationOptions<RestoreEventMutation, RestoreEventMutationVariables>;
export const EditPlayerDocument = gql`
    mutation EditPlayer($id: ID!, $input: PlayerInput!) {
  playerUpdate(id: $id, input: $input) {
    player {
      id
      ...EditPlayerDropdownItem
    }
    errors {
      ...Errors
    }
  }
}
    ${EditPlayerDropdownItemFragmentDoc}
${ErrorsFragmentDoc}`;
export type EditPlayerMutationFn = Apollo.MutationFunction<EditPlayerMutation, EditPlayerMutationVariables>;

/**
 * __useEditPlayerMutation__
 *
 * To run a mutation, you first call `useEditPlayerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditPlayerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editPlayerMutation, { data, loading, error }] = useEditPlayerMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useEditPlayerMutation(baseOptions?: Apollo.MutationHookOptions<EditPlayerMutation, EditPlayerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EditPlayerMutation, EditPlayerMutationVariables>(EditPlayerDocument, options);
      }
export type EditPlayerMutationHookResult = ReturnType<typeof useEditPlayerMutation>;
export type EditPlayerMutationResult = Apollo.MutationResult<EditPlayerMutation>;
export type EditPlayerMutationOptions = Apollo.BaseMutationOptions<EditPlayerMutation, EditPlayerMutationVariables>;
export const PlayerActionsUpdateDocument = gql`
    mutation PlayerActionsUpdate($id: ID!, $input: PlayerInput!) {
  playerUpdate(id: $id, input: $input) {
    player {
      id
      ...PlayerActionsDropdown
    }
    errors {
      attribute
      message
    }
  }
}
    ${PlayerActionsDropdownFragmentDoc}`;
export type PlayerActionsUpdateMutationFn = Apollo.MutationFunction<PlayerActionsUpdateMutation, PlayerActionsUpdateMutationVariables>;

/**
 * __usePlayerActionsUpdateMutation__
 *
 * To run a mutation, you first call `usePlayerActionsUpdateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePlayerActionsUpdateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [playerActionsUpdateMutation, { data, loading, error }] = usePlayerActionsUpdateMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function usePlayerActionsUpdateMutation(baseOptions?: Apollo.MutationHookOptions<PlayerActionsUpdateMutation, PlayerActionsUpdateMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PlayerActionsUpdateMutation, PlayerActionsUpdateMutationVariables>(PlayerActionsUpdateDocument, options);
      }
export type PlayerActionsUpdateMutationHookResult = ReturnType<typeof usePlayerActionsUpdateMutation>;
export type PlayerActionsUpdateMutationResult = Apollo.MutationResult<PlayerActionsUpdateMutation>;
export type PlayerActionsUpdateMutationOptions = Apollo.BaseMutationOptions<PlayerActionsUpdateMutation, PlayerActionsUpdateMutationVariables>;
export const PlayerActionsDeleteDocument = gql`
    mutation PlayerActionsDelete($id: ID!) {
  playerDelete(id: $id) {
    success
    errors {
      attribute
      message
    }
  }
}
    `;
export type PlayerActionsDeleteMutationFn = Apollo.MutationFunction<PlayerActionsDeleteMutation, PlayerActionsDeleteMutationVariables>;

/**
 * __usePlayerActionsDeleteMutation__
 *
 * To run a mutation, you first call `usePlayerActionsDeleteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePlayerActionsDeleteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [playerActionsDeleteMutation, { data, loading, error }] = usePlayerActionsDeleteMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePlayerActionsDeleteMutation(baseOptions?: Apollo.MutationHookOptions<PlayerActionsDeleteMutation, PlayerActionsDeleteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PlayerActionsDeleteMutation, PlayerActionsDeleteMutationVariables>(PlayerActionsDeleteDocument, options);
      }
export type PlayerActionsDeleteMutationHookResult = ReturnType<typeof usePlayerActionsDeleteMutation>;
export type PlayerActionsDeleteMutationResult = Apollo.MutationResult<PlayerActionsDeleteMutation>;
export type PlayerActionsDeleteMutationOptions = Apollo.BaseMutationOptions<PlayerActionsDeleteMutation, PlayerActionsDeleteMutationVariables>;
export const PlayersForEditRoundDocument = gql`
    query PlayersForEditRound($roundID: ID!) {
  round(id: $roundID) {
    id
    players(deleted: ALL) {
      id
      ...MatchFormInputPlayer
    }
    unpairedPlayers(deleted: NON_DELETED) {
      id
      ...MatchFormInputPlayer
    }
  }
}
    ${MatchFormInputPlayerFragmentDoc}`;

/**
 * __usePlayersForEditRoundQuery__
 *
 * To run a query within a React component, call `usePlayersForEditRoundQuery` and pass it any options that fit your needs.
 * When your component renders, `usePlayersForEditRoundQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePlayersForEditRoundQuery({
 *   variables: {
 *      roundID: // value for 'roundID'
 *   },
 * });
 */
export function usePlayersForEditRoundQuery(baseOptions: Apollo.QueryHookOptions<PlayersForEditRoundQuery, PlayersForEditRoundQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PlayersForEditRoundQuery, PlayersForEditRoundQueryVariables>(PlayersForEditRoundDocument, options);
      }
export function usePlayersForEditRoundLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PlayersForEditRoundQuery, PlayersForEditRoundQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PlayersForEditRoundQuery, PlayersForEditRoundQueryVariables>(PlayersForEditRoundDocument, options);
        }
export type PlayersForEditRoundQueryHookResult = ReturnType<typeof usePlayersForEditRoundQuery>;
export type PlayersForEditRoundLazyQueryHookResult = ReturnType<typeof usePlayersForEditRoundLazyQuery>;
export type PlayersForEditRoundQueryResult = Apollo.QueryResult<PlayersForEditRoundQuery, PlayersForEditRoundQueryVariables>;
export const UpdateRoundDocument = gql`
    mutation UpdateRound($roundID: ID!, $roundInput: RoundInput!) {
  roundUpdate(id: $roundID, input: $roundInput) {
    round {
      id
      ...EditRoundDropdownItem
    }
    errors {
      ...Errors
    }
  }
}
    ${EditRoundDropdownItemFragmentDoc}
${ErrorsFragmentDoc}`;
export type UpdateRoundMutationFn = Apollo.MutationFunction<UpdateRoundMutation, UpdateRoundMutationVariables>;

/**
 * __useUpdateRoundMutation__
 *
 * To run a mutation, you first call `useUpdateRoundMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateRoundMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateRoundMutation, { data, loading, error }] = useUpdateRoundMutation({
 *   variables: {
 *      roundID: // value for 'roundID'
 *      roundInput: // value for 'roundInput'
 *   },
 * });
 */
export function useUpdateRoundMutation(baseOptions?: Apollo.MutationHookOptions<UpdateRoundMutation, UpdateRoundMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateRoundMutation, UpdateRoundMutationVariables>(UpdateRoundDocument, options);
      }
export type UpdateRoundMutationHookResult = ReturnType<typeof useUpdateRoundMutation>;
export type UpdateRoundMutationResult = Apollo.MutationResult<UpdateRoundMutation>;
export type UpdateRoundMutationOptions = Apollo.BaseMutationOptions<UpdateRoundMutation, UpdateRoundMutationVariables>;
export const DeleteRoundDocument = gql`
    mutation DeleteRound($id: ID!) {
  roundDelete(id: $id) {
    success
    errors {
      ...Errors
    }
  }
}
    ${ErrorsFragmentDoc}`;
export type DeleteRoundMutationFn = Apollo.MutationFunction<DeleteRoundMutation, DeleteRoundMutationVariables>;

/**
 * __useDeleteRoundMutation__
 *
 * To run a mutation, you first call `useDeleteRoundMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteRoundMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteRoundMutation, { data, loading, error }] = useDeleteRoundMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteRoundMutation(baseOptions?: Apollo.MutationHookOptions<DeleteRoundMutation, DeleteRoundMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteRoundMutation, DeleteRoundMutationVariables>(DeleteRoundDocument, options);
      }
export type DeleteRoundMutationHookResult = ReturnType<typeof useDeleteRoundMutation>;
export type DeleteRoundMutationResult = Apollo.MutationResult<DeleteRoundMutation>;
export type DeleteRoundMutationOptions = Apollo.BaseMutationOptions<DeleteRoundMutation, DeleteRoundMutationVariables>;
export const SetMatchResolutionDocument = gql`
    mutation SetMatchResolution($id: ID!, $winnerId: ID, $draw: Boolean!) {
  matchUpdate(id: $id, input: {winnerId: $winnerId, draw: $draw}) {
    match {
      id
      winnerId
      draw
    }
    errors {
      ...Errors
    }
  }
}
    ${ErrorsFragmentDoc}`;
export type SetMatchResolutionMutationFn = Apollo.MutationFunction<SetMatchResolutionMutation, SetMatchResolutionMutationVariables>;

/**
 * __useSetMatchResolutionMutation__
 *
 * To run a mutation, you first call `useSetMatchResolutionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetMatchResolutionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setMatchResolutionMutation, { data, loading, error }] = useSetMatchResolutionMutation({
 *   variables: {
 *      id: // value for 'id'
 *      winnerId: // value for 'winnerId'
 *      draw: // value for 'draw'
 *   },
 * });
 */
export function useSetMatchResolutionMutation(baseOptions?: Apollo.MutationHookOptions<SetMatchResolutionMutation, SetMatchResolutionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SetMatchResolutionMutation, SetMatchResolutionMutationVariables>(SetMatchResolutionDocument, options);
      }
export type SetMatchResolutionMutationHookResult = ReturnType<typeof useSetMatchResolutionMutation>;
export type SetMatchResolutionMutationResult = Apollo.MutationResult<SetMatchResolutionMutation>;
export type SetMatchResolutionMutationOptions = Apollo.BaseMutationOptions<SetMatchResolutionMutation, SetMatchResolutionMutationVariables>;
export const GeneratePairingsDocument = gql`
    mutation GeneratePairings($eventId: ID!, $playerIds: [ID!]!) {
  eventGeneratePairings(eventId: $eventId, playerIds: $playerIds) {
    pairings {
      player1 {
        id
        name
      }
      player2 {
        id
        name
      }
    }
  }
}
    `;
export type GeneratePairingsMutationFn = Apollo.MutationFunction<GeneratePairingsMutation, GeneratePairingsMutationVariables>;

/**
 * __useGeneratePairingsMutation__
 *
 * To run a mutation, you first call `useGeneratePairingsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGeneratePairingsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [generatePairingsMutation, { data, loading, error }] = useGeneratePairingsMutation({
 *   variables: {
 *      eventId: // value for 'eventId'
 *      playerIds: // value for 'playerIds'
 *   },
 * });
 */
export function useGeneratePairingsMutation(baseOptions?: Apollo.MutationHookOptions<GeneratePairingsMutation, GeneratePairingsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<GeneratePairingsMutation, GeneratePairingsMutationVariables>(GeneratePairingsDocument, options);
      }
export type GeneratePairingsMutationHookResult = ReturnType<typeof useGeneratePairingsMutation>;
export type GeneratePairingsMutationResult = Apollo.MutationResult<GeneratePairingsMutation>;
export type GeneratePairingsMutationOptions = Apollo.BaseMutationOptions<GeneratePairingsMutation, GeneratePairingsMutationVariables>;
export const EventShowDocument = gql`
    query EventShow($id: ID!) {
  event(id: $id) {
    id
    name
    ...EventLayout
  }
}
    ${EventLayoutFragmentDoc}`;

/**
 * __useEventShowQuery__
 *
 * To run a query within a React component, call `useEventShowQuery` and pass it any options that fit your needs.
 * When your component renders, `useEventShowQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEventShowQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useEventShowQuery(baseOptions: Apollo.QueryHookOptions<EventShowQuery, EventShowQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EventShowQuery, EventShowQueryVariables>(EventShowDocument, options);
      }
export function useEventShowLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventShowQuery, EventShowQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EventShowQuery, EventShowQueryVariables>(EventShowDocument, options);
        }
export type EventShowQueryHookResult = ReturnType<typeof useEventShowQuery>;
export type EventShowLazyQueryHookResult = ReturnType<typeof useEventShowLazyQuery>;
export type EventShowQueryResult = Apollo.QueryResult<EventShowQuery, EventShowQueryVariables>;
export const EventMatchesDocument = gql`
    query EventMatches($id: ID!, $deleted: DeletedFilter) {
  event(id: $id) {
    id
    name
    ...EventLayout
    ...CreateRoundButton
    rounds(deleted: $deleted, orderBy: NUMBER, orderByDirection: DESC) {
      ...RoundListItem
    }
    players {
      totalCount
    }
  }
}
    ${EventLayoutFragmentDoc}
${CreateRoundButtonFragmentDoc}
${RoundListItemFragmentDoc}`;

/**
 * __useEventMatchesQuery__
 *
 * To run a query within a React component, call `useEventMatchesQuery` and pass it any options that fit your needs.
 * When your component renders, `useEventMatchesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEventMatchesQuery({
 *   variables: {
 *      id: // value for 'id'
 *      deleted: // value for 'deleted'
 *   },
 * });
 */
export function useEventMatchesQuery(baseOptions: Apollo.QueryHookOptions<EventMatchesQuery, EventMatchesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EventMatchesQuery, EventMatchesQueryVariables>(EventMatchesDocument, options);
      }
export function useEventMatchesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventMatchesQuery, EventMatchesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EventMatchesQuery, EventMatchesQueryVariables>(EventMatchesDocument, options);
        }
export type EventMatchesQueryHookResult = ReturnType<typeof useEventMatchesQuery>;
export type EventMatchesLazyQueryHookResult = ReturnType<typeof useEventMatchesLazyQuery>;
export type EventMatchesQueryResult = Apollo.QueryResult<EventMatchesQuery, EventMatchesQueryVariables>;
export const EventPlayersDocument = gql`
    query EventPlayers($id: ID!, $deleted: DeletedFilter) {
  event(id: $id) {
    id
    name
    ...EventLayout
    ...CreatePlayerButton
    players(deleted: $deleted) {
      nodes {
        ...PlayerTable
      }
    }
  }
}
    ${EventLayoutFragmentDoc}
${CreatePlayerButtonFragmentDoc}
${PlayerTableFragmentDoc}`;

/**
 * __useEventPlayersQuery__
 *
 * To run a query within a React component, call `useEventPlayersQuery` and pass it any options that fit your needs.
 * When your component renders, `useEventPlayersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEventPlayersQuery({
 *   variables: {
 *      id: // value for 'id'
 *      deleted: // value for 'deleted'
 *   },
 * });
 */
export function useEventPlayersQuery(baseOptions: Apollo.QueryHookOptions<EventPlayersQuery, EventPlayersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EventPlayersQuery, EventPlayersQueryVariables>(EventPlayersDocument, options);
      }
export function useEventPlayersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventPlayersQuery, EventPlayersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EventPlayersQuery, EventPlayersQueryVariables>(EventPlayersDocument, options);
        }
export type EventPlayersQueryHookResult = ReturnType<typeof useEventPlayersQuery>;
export type EventPlayersLazyQueryHookResult = ReturnType<typeof useEventPlayersLazyQuery>;
export type EventPlayersQueryResult = Apollo.QueryResult<EventPlayersQuery, EventPlayersQueryVariables>;
export const EventSlipsDocument = gql`
    query EventSlips($id: ID!) {
  event(id: $id) {
    id
    name
    ...EventLayout
    ...SlipEvent
    rounds(orderBy: NUMBER, orderByDirection: DESC) {
      id
      ...SlipRound
      matches {
        ...SlipMatch
      }
    }
  }
}
    ${EventLayoutFragmentDoc}
${SlipEventFragmentDoc}
${SlipRoundFragmentDoc}
${SlipMatchFragmentDoc}`;

/**
 * __useEventSlipsQuery__
 *
 * To run a query within a React component, call `useEventSlipsQuery` and pass it any options that fit your needs.
 * When your component renders, `useEventSlipsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEventSlipsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useEventSlipsQuery(baseOptions: Apollo.QueryHookOptions<EventSlipsQuery, EventSlipsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EventSlipsQuery, EventSlipsQueryVariables>(EventSlipsDocument, options);
      }
export function useEventSlipsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventSlipsQuery, EventSlipsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EventSlipsQuery, EventSlipsQueryVariables>(EventSlipsDocument, options);
        }
export type EventSlipsQueryHookResult = ReturnType<typeof useEventSlipsQuery>;
export type EventSlipsLazyQueryHookResult = ReturnType<typeof useEventSlipsLazyQuery>;
export type EventSlipsQueryResult = Apollo.QueryResult<EventSlipsQuery, EventSlipsQueryVariables>;
export const EventsIndexDocument = gql`
    query EventsIndex($deleted: DeletedFilter) {
  events(deleted: $deleted) {
    ...EventList
  }
}
    ${EventListFragmentDoc}`;

/**
 * __useEventsIndexQuery__
 *
 * To run a query within a React component, call `useEventsIndexQuery` and pass it any options that fit your needs.
 * When your component renders, `useEventsIndexQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEventsIndexQuery({
 *   variables: {
 *      deleted: // value for 'deleted'
 *   },
 * });
 */
export function useEventsIndexQuery(baseOptions?: Apollo.QueryHookOptions<EventsIndexQuery, EventsIndexQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EventsIndexQuery, EventsIndexQueryVariables>(EventsIndexDocument, options);
      }
export function useEventsIndexLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventsIndexQuery, EventsIndexQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EventsIndexQuery, EventsIndexQueryVariables>(EventsIndexDocument, options);
        }
export type EventsIndexQueryHookResult = ReturnType<typeof useEventsIndexQuery>;
export type EventsIndexLazyQueryHookResult = ReturnType<typeof useEventsIndexLazyQuery>;
export type EventsIndexQueryResult = Apollo.QueryResult<EventsIndexQuery, EventsIndexQueryVariables>;

      export interface PossibleTypesResultData {
        possibleTypes: {
          [key: string]: string[]
        }
      }
      const result: PossibleTypesResultData = {
  "possibleTypes": {}
};
      export default result;
    
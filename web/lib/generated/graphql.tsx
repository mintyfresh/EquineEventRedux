import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  ISO8601DateTime: any;
  ISO8601Duration: any;
};

export type AudioClip = {
  __typename?: 'AudioClip';
  contentType: Scalars['String'];
  fileName: Scalars['String'];
  fileSize: Scalars['Int'];
  fileUrl: Scalars['String'];
  id: Scalars['ID'];
  /** Whether this audio clip is system-defined */
  isSystem: Scalars['Boolean'];
  name: Scalars['String'];
};

/** The connection type for AudioClip. */
export type AudioClipConnection = {
  __typename?: 'AudioClipConnection';
  /** A list of edges. */
  edges: Array<AudioClipEdge>;
  /** A list of nodes. */
  nodes: Array<AudioClip>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AudioClipEdge = {
  __typename?: 'AudioClipEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<AudioClip>;
};

export enum DeletedFilter {
  /** Returns both deleted and non-deleted records */
  All = 'ALL',
  /** Returns only deleted records */
  Deleted = 'DELETED',
  /** Returns only non-deleted records */
  NonDeleted = 'NON_DELETED'
}

export type Error = {
  __typename?: 'Error';
  attribute: Scalars['String'];
  message: Scalars['String'];
};


export type ErrorMessageArgs = {
  full?: InputMaybe<Scalars['Boolean']>;
};

export type Event = {
  __typename?: 'Event';
  createdAt: Scalars['ISO8601DateTime'];
  deleted: Scalars['Boolean'];
  deletedAt?: Maybe<Scalars['ISO8601DateTime']>;
  id: Scalars['ID'];
  name: Scalars['String'];
  players: PlayerConnection;
  rounds: Array<Round>;
  slug: Scalars['String'];
  timers: Array<Timer>;
};


export type EventPlayersArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  deleted?: InputMaybe<DeletedFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<EventPlayersOrderBy>;
  orderByDirection?: InputMaybe<OrderByDirection>;
};


export type EventRoundsArgs = {
  deleted?: InputMaybe<DeletedFilter>;
  orderBy?: InputMaybe<EventRoundsOrderBy>;
  orderByDirection?: InputMaybe<OrderByDirection>;
};

/** The connection type for Event. */
export type EventConnection = {
  __typename?: 'EventConnection';
  /** A list of edges. */
  edges: Array<EventEdge>;
  /** A list of nodes. */
  nodes: Array<Event>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated return type of EventCreate. */
export type EventCreatePayload = {
  __typename?: 'EventCreatePayload';
  errors?: Maybe<Array<Error>>;
  event?: Maybe<Event>;
};

/** Autogenerated return type of EventDelete. */
export type EventDeletePayload = {
  __typename?: 'EventDeletePayload';
  errors?: Maybe<Array<Error>>;
  success?: Maybe<Scalars['Boolean']>;
};

/** An edge in a connection. */
export type EventEdge = {
  __typename?: 'EventEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Event>;
};

/** Autogenerated return type of EventGeneratePairings. */
export type EventGeneratePairingsPayload = {
  __typename?: 'EventGeneratePairingsPayload';
  pairings: Array<Pairing>;
};

export type EventInput = {
  name?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of EventPauseAllTimers. */
export type EventPauseAllTimersPayload = {
  __typename?: 'EventPauseAllTimersPayload';
  errors?: Maybe<Array<Error>>;
  /** The event for which the timers were paused. */
  event?: Maybe<Event>;
  /** The timers that were paused. */
  timers?: Maybe<Array<Timer>>;
};

export enum EventPlayersOrderBy {
  DrawsCount = 'DRAWS_COUNT',
  LossesCount = 'LOSSES_COUNT',
  Name = 'NAME',
  Score = 'SCORE',
  WinsCount = 'WINS_COUNT'
}

/** Autogenerated return type of EventRestore. */
export type EventRestorePayload = {
  __typename?: 'EventRestorePayload';
  errors?: Maybe<Array<Error>>;
  event?: Maybe<Event>;
};

export enum EventRoundsOrderBy {
  Number = 'NUMBER'
}

/** Autogenerated return type of EventUnpauseAllTimers. */
export type EventUnpauseAllTimersPayload = {
  __typename?: 'EventUnpauseAllTimersPayload';
  errors?: Maybe<Array<Error>>;
  /** The event for which the timers were unpaused. */
  event?: Maybe<Event>;
  /** The timers that were unpaused. */
  timers?: Maybe<Array<Timer>>;
};

/** Autogenerated return type of EventUpdate. */
export type EventUpdatePayload = {
  __typename?: 'EventUpdatePayload';
  errors?: Maybe<Array<Error>>;
  event?: Maybe<Event>;
};

export type Match = {
  __typename?: 'Match';
  draw: Scalars['Boolean'];
  id: Scalars['ID'];
  player1: Player;
  player1Id: Scalars['ID'];
  player2?: Maybe<Player>;
  player2Id?: Maybe<Scalars['ID']>;
  round: Round;
  roundId: Scalars['ID'];
  table: Scalars['Int'];
  winnerId?: Maybe<Scalars['ID']>;
};

export type MatchInput = {
  _destroy?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['ID']>;
  player1Id: Scalars['ID'];
  player2Id?: InputMaybe<Scalars['ID']>;
  table: Scalars['Int'];
};

export type MatchUpdateInput = {
  draw?: InputMaybe<Scalars['Boolean']>;
  winnerId?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of MatchUpdate. */
export type MatchUpdatePayload = {
  __typename?: 'MatchUpdatePayload';
  errors?: Maybe<Array<Error>>;
  match?: Maybe<Match>;
};

export type Mutation = {
  __typename?: 'Mutation';
  /** Creates a new Event */
  eventCreate?: Maybe<EventCreatePayload>;
  /** Deletes an existing Event by ID */
  eventDelete?: Maybe<EventDeletePayload>;
  /** Generates a possible list of pairings for a round. */
  eventGeneratePairings?: Maybe<EventGeneratePairingsPayload>;
  eventPauseAllTimers?: Maybe<EventPauseAllTimersPayload>;
  /** Restores a deleted Event by ID */
  eventRestore?: Maybe<EventRestorePayload>;
  eventUnpauseAllTimers?: Maybe<EventUnpauseAllTimersPayload>;
  /** Updates an existing Event by ID */
  eventUpdate?: Maybe<EventUpdatePayload>;
  /** Updates an existing Match by ID */
  matchUpdate?: Maybe<MatchUpdatePayload>;
  /** Creates a new Player */
  playerCreate?: Maybe<PlayerCreatePayload>;
  /** Deletes an existing Player by ID */
  playerDelete?: Maybe<PlayerDeletePayload>;
  playerImportBulk?: Maybe<PlayerImportBulkPayload>;
  /** Restores a deleted Player by ID */
  playerRestore?: Maybe<PlayerRestorePayload>;
  /** Updates an existing Player by ID */
  playerUpdate?: Maybe<PlayerUpdatePayload>;
  /** Creates a new Round */
  roundCreate?: Maybe<RoundCreatePayload>;
  /** Deletes an existing Round by ID */
  roundDelete?: Maybe<RoundDeletePayload>;
  /** Restores a deleted Round by ID */
  roundRestore?: Maybe<RoundRestorePayload>;
  /** Updates an existing Round by ID */
  roundUpdate?: Maybe<RoundUpdatePayload>;
  timerCloneWithOffset?: Maybe<TimerCloneWithOffsetPayload>;
  /** Creates a new Timer */
  timerCreate?: Maybe<TimerCreatePayload>;
  /** Deletes an existing Timer by ID */
  timerDelete?: Maybe<TimerDeletePayload>;
  timerPause?: Maybe<TimerPausePayload>;
  /** Reset a timer to its initial state */
  timerReset?: Maybe<TimerResetPayload>;
  timerSkipToNextPhase?: Maybe<TimerSkipToNextPhasePayload>;
  timerUnpause?: Maybe<TimerUnpausePayload>;
  /** Updates an existing Timer by ID */
  timerUpdate?: Maybe<TimerUpdatePayload>;
};


export type MutationEventCreateArgs = {
  input: EventInput;
};


export type MutationEventDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationEventGeneratePairingsArgs = {
  eventId: Scalars['ID'];
  playerIds: Array<Scalars['ID']>;
};


export type MutationEventPauseAllTimersArgs = {
  eventId: Scalars['ID'];
};


export type MutationEventRestoreArgs = {
  id: Scalars['ID'];
};


export type MutationEventUnpauseAllTimersArgs = {
  eventId: Scalars['ID'];
};


export type MutationEventUpdateArgs = {
  id: Scalars['ID'];
  input: EventInput;
};


export type MutationMatchUpdateArgs = {
  id: Scalars['ID'];
  input: MatchUpdateInput;
};


export type MutationPlayerCreateArgs = {
  eventId: Scalars['ID'];
  input: PlayerInput;
};


export type MutationPlayerDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationPlayerImportBulkArgs = {
  input: PlayerImportBulkInput;
};


export type MutationPlayerRestoreArgs = {
  id: Scalars['ID'];
};


export type MutationPlayerUpdateArgs = {
  id: Scalars['ID'];
  input: PlayerInput;
};


export type MutationRoundCreateArgs = {
  eventId: Scalars['ID'];
  input: RoundInput;
};


export type MutationRoundDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationRoundRestoreArgs = {
  id: Scalars['ID'];
};


export type MutationRoundUpdateArgs = {
  id: Scalars['ID'];
  input: RoundInput;
};


export type MutationTimerCloneWithOffsetArgs = {
  id: Scalars['ID'];
  input: TimerCloneWithOffsetInput;
};


export type MutationTimerCreateArgs = {
  eventId: Scalars['ID'];
  input: TimerCreateInput;
};


export type MutationTimerDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationTimerPauseArgs = {
  id: Scalars['ID'];
};


export type MutationTimerResetArgs = {
  id: Scalars['ID'];
  paused?: InputMaybe<Scalars['Boolean']>;
};


export type MutationTimerSkipToNextPhaseArgs = {
  id: Scalars['ID'];
};


export type MutationTimerUnpauseArgs = {
  id: Scalars['ID'];
};


export type MutationTimerUpdateArgs = {
  id: Scalars['ID'];
  input: TimerUpdateInput;
};

export enum OrderByDirection {
  /** Indicates that the results should be sorted in ascending order, from smallest to largest. */
  Asc = 'ASC',
  /** Indicates that the results should be sorted in descending order, from largest to smallest. */
  Desc = 'DESC'
}

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']>;
};

export type Pairing = {
  __typename?: 'Pairing';
  player1: Player;
  player2?: Maybe<Player>;
};

export type Player = {
  __typename?: 'Player';
  completedMatchesCount: Scalars['Int'];
  deleted: Scalars['Boolean'];
  deletedAt?: Maybe<Scalars['ISO8601DateTime']>;
  drawsCount: Scalars['Int'];
  dropped: Scalars['Boolean'];
  eventId: Scalars['ID'];
  id: Scalars['ID'];
  lossesCount: Scalars['Int'];
  maximumPossibleScore: Scalars['Int'];
  name: Scalars['String'];
  opponentIds: Array<Scalars['ID']>;
  opponentWinRate: Scalars['Float'];
  paid: Scalars['Boolean'];
  score: Scalars['Int'];
  winsCount: Scalars['Int'];
};

/** The connection type for Player. */
export type PlayerConnection = {
  __typename?: 'PlayerConnection';
  /** A list of edges. */
  edges: Array<PlayerEdge>;
  /** A list of nodes. */
  nodes: Array<Player>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** Autogenerated return type of PlayerCreate. */
export type PlayerCreatePayload = {
  __typename?: 'PlayerCreatePayload';
  errors?: Maybe<Array<Error>>;
  /** The Event that the Player was added to */
  event?: Maybe<Event>;
  player?: Maybe<Player>;
};

/** Autogenerated return type of PlayerDelete. */
export type PlayerDeletePayload = {
  __typename?: 'PlayerDeletePayload';
  errors?: Maybe<Array<Error>>;
  success?: Maybe<Scalars['Boolean']>;
};

/** An edge in a connection. */
export type PlayerEdge = {
  __typename?: 'PlayerEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Player>;
};

export type PlayerImportBulkInput = {
  eventId: Scalars['ID'];
  paid?: InputMaybe<Scalars['Boolean']>;
  playerNames: Array<Scalars['String']>;
};

/** Autogenerated return type of PlayerImportBulk. */
export type PlayerImportBulkPayload = {
  __typename?: 'PlayerImportBulkPayload';
  errors?: Maybe<Array<Error>>;
  event?: Maybe<Event>;
  players?: Maybe<Array<Player>>;
};

export type PlayerInput = {
  dropped?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  paid?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of PlayerRestore. */
export type PlayerRestorePayload = {
  __typename?: 'PlayerRestorePayload';
  errors?: Maybe<Array<Error>>;
  player?: Maybe<Player>;
};

/** Autogenerated return type of PlayerUpdate. */
export type PlayerUpdatePayload = {
  __typename?: 'PlayerUpdatePayload';
  errors?: Maybe<Array<Error>>;
  player?: Maybe<Player>;
};

export type Query = {
  __typename?: 'Query';
  /** Finds a AudioClip by ID */
  audioClip: AudioClip;
  /** Finds a list of AudioClip objects */
  audioClips: AudioClipConnection;
  /** Finds a Event by ID */
  event: Event;
  /** Finds a list of Event objects */
  events: EventConnection;
  /** Finds a Match by ID */
  match: Match;
  /** Finds a Player by ID */
  player: Player;
  /** Finds a Round by ID */
  round: Round;
  /** Finds a TimerPreset by ID */
  timerPreset: TimerPreset;
  /** Finds a list of TimerPreset objects */
  timerPresets: TimerPresetConnection;
};


export type QueryAudioClipArgs = {
  id: Scalars['ID'];
};


export type QueryAudioClipsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueryEventArgs = {
  id: Scalars['ID'];
};


export type QueryEventsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  deleted?: InputMaybe<DeletedFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueryMatchArgs = {
  id: Scalars['ID'];
};


export type QueryPlayerArgs = {
  id: Scalars['ID'];
};


export type QueryRoundArgs = {
  id: Scalars['ID'];
};


export type QueryTimerPresetArgs = {
  id: Scalars['ID'];
};


export type QueryTimerPresetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type Round = {
  __typename?: 'Round';
  eventId: Scalars['ID'];
  id: Scalars['ID'];
  /** Whether all matches have been played (must include at least one match) */
  isComplete: Scalars['Boolean'];
  matches: Array<Match>;
  number: Scalars['Int'];
  players: Array<Player>;
  unpairedPlayers: Array<Player>;
};


export type RoundPlayersArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']>;
  deleted?: InputMaybe<DeletedFilter>;
};


export type RoundUnpairedPlayersArgs = {
  activeOnly?: InputMaybe<Scalars['Boolean']>;
  deleted?: InputMaybe<DeletedFilter>;
};

/** Autogenerated return type of RoundCreate. */
export type RoundCreatePayload = {
  __typename?: 'RoundCreatePayload';
  errors?: Maybe<Array<Error>>;
  /** The Event that the Round was added to */
  event?: Maybe<Event>;
  round?: Maybe<Round>;
};

/** Autogenerated return type of RoundDelete. */
export type RoundDeletePayload = {
  __typename?: 'RoundDeletePayload';
  errors?: Maybe<Array<Error>>;
  success?: Maybe<Scalars['Boolean']>;
};

export type RoundInput = {
  matches?: InputMaybe<Array<MatchInput>>;
};

/** Autogenerated return type of RoundRestore. */
export type RoundRestorePayload = {
  __typename?: 'RoundRestorePayload';
  errors?: Maybe<Array<Error>>;
  round?: Maybe<Round>;
};

/** Autogenerated return type of RoundUpdate. */
export type RoundUpdatePayload = {
  __typename?: 'RoundUpdatePayload';
  errors?: Maybe<Array<Error>>;
  round?: Maybe<Round>;
};

export type Subscription = {
  __typename?: 'Subscription';
  timerDeleted: TimerDeletedPayload;
  timerEvent: TimerEventPayload;
};


export type SubscriptionTimerDeletedArgs = {
  eventId: Scalars['ID'];
};


export type SubscriptionTimerEventArgs = {
  eventId: Scalars['ID'];
};

export type Timer = {
  __typename?: 'Timer';
  expiresAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  /** The local current time when the query was executed, to which all other times are relative */
  instant: Scalars['ISO8601DateTime'];
  isExpired: Scalars['Boolean'];
  isPaused: Scalars['Boolean'];
  label?: Maybe<Scalars['String']>;
  pausedAt?: Maybe<Scalars['ISO8601DateTime']>;
  phases: Array<TimerPhase>;
  preset: TimerPreset;
  /** The amount of time that has elapsed since the timer started, in seconds */
  timeElapsed: Scalars['Float'];
  /** The amount of time remaining in the current phase, in seconds */
  timeRemaining: Scalars['Float'];
  /** The amount of time remaining in the current phase, in seconds */
  timeRemainingInPhase: Scalars['Float'];
  /** The total duration of the timer */
  totalDuration: Scalars['ISO8601Duration'];
  /** The total duration of the timer, in seconds */
  totalDurationInSeconds: Scalars['Int'];
};

export type TimerCloneWithOffsetInput = {
  offsetInSeconds?: InputMaybe<Scalars['Int']>;
  /** If true, the timer will be paused after cloning */
  paused?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of TimerCloneWithOffset. */
export type TimerCloneWithOffsetPayload = {
  __typename?: 'TimerCloneWithOffsetPayload';
  errors?: Maybe<Array<Error>>;
  timer?: Maybe<Timer>;
};

export type TimerCreateInput = {
  label?: InputMaybe<Scalars['String']>;
  presetId: Scalars['ID'];
};

/** Autogenerated return type of TimerCreate. */
export type TimerCreatePayload = {
  __typename?: 'TimerCreatePayload';
  errors?: Maybe<Array<Error>>;
  /** The Event to which the Timer was added */
  event?: Maybe<Event>;
  timer?: Maybe<Timer>;
};

/** Autogenerated return type of TimerDelete. */
export type TimerDeletePayload = {
  __typename?: 'TimerDeletePayload';
  errors?: Maybe<Array<Error>>;
  success?: Maybe<Scalars['Boolean']>;
};

/** Autogenerated return type of TimerDeleted. */
export type TimerDeletedPayload = {
  __typename?: 'TimerDeletedPayload';
  timerId: Scalars['ID'];
};

/** Autogenerated return type of TimerEvent. */
export type TimerEventPayload = {
  __typename?: 'TimerEventPayload';
  eventType?: Maybe<TimerEventType>;
  timer?: Maybe<Timer>;
};

export enum TimerEventType {
  Create = 'CREATE',
  Ended = 'ENDED',
  Pause = 'PAUSE',
  Reset = 'RESET',
  SkipToNextPhase = 'SKIP_TO_NEXT_PHASE',
  Sync = 'SYNC',
  Unpause = 'UNPAUSE',
  Update = 'UPDATE'
}

/** Autogenerated return type of TimerPause. */
export type TimerPausePayload = {
  __typename?: 'TimerPausePayload';
  errors?: Maybe<Array<Error>>;
  result?: Maybe<Scalars['Boolean']>;
  timer?: Maybe<Timer>;
};

export type TimerPhase = {
  __typename?: 'TimerPhase';
  audioClip?: Maybe<AudioClip>;
  duration: Scalars['ISO8601Duration'];
  durationAmount: Scalars['Int'];
  durationInSeconds: Scalars['Int'];
  durationUnit: TimerPhaseDurationUnit;
  id: Scalars['ID'];
  name: Scalars['String'];
  /** The number of seconds from the end of this phase to the end of the timer (after this phase) */
  offsetFromEnd: Scalars['Int'];
  /** The number of seconds from the start of the timer to the start of this phase (before this phase) */
  offsetFromStart: Scalars['Int'];
  position: Scalars['Int'];
};

export enum TimerPhaseDurationUnit {
  Hours = 'HOURS',
  Minutes = 'MINUTES',
  Seconds = 'SECONDS'
}

export type TimerPreset = {
  __typename?: 'TimerPreset';
  id: Scalars['ID'];
  /** Whether this timer preset is system-defined */
  isSystem: Scalars['Boolean'];
  name: Scalars['String'];
  phases: Array<TimerPresetPhase>;
  phasesCount: Scalars['Int'];
  totalDuration: Scalars['ISO8601Duration'];
  totalDurationInSeconds: Scalars['Int'];
};

/** The connection type for TimerPreset. */
export type TimerPresetConnection = {
  __typename?: 'TimerPresetConnection';
  /** A list of edges. */
  edges: Array<TimerPresetEdge>;
  /** A list of nodes. */
  nodes: Array<TimerPreset>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type TimerPresetEdge = {
  __typename?: 'TimerPresetEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<TimerPreset>;
};

export type TimerPresetPhase = {
  __typename?: 'TimerPresetPhase';
  audioClip?: Maybe<AudioClip>;
  duration: Scalars['ISO8601Duration'];
  durationAmount: Scalars['Int'];
  durationInSeconds: Scalars['Int'];
  durationUnit: TimerPhaseDurationUnit;
  id: Scalars['ID'];
  name: Scalars['String'];
  /** The number of seconds from the end of this phase to the end of the timer (after this phase) */
  offsetFromEnd: Scalars['Int'];
  /** The number of seconds from the start of the timer to the start of this phase (before this phase) */
  offsetFromStart: Scalars['Int'];
  position: Scalars['Int'];
};

/** Autogenerated return type of TimerReset. */
export type TimerResetPayload = {
  __typename?: 'TimerResetPayload';
  errors?: Maybe<Array<Error>>;
  result?: Maybe<Scalars['Boolean']>;
  timer?: Maybe<Timer>;
};

/** Autogenerated return type of TimerSkipToNextPhase. */
export type TimerSkipToNextPhasePayload = {
  __typename?: 'TimerSkipToNextPhasePayload';
  errors?: Maybe<Array<Error>>;
  result?: Maybe<Scalars['Boolean']>;
  timer?: Maybe<Timer>;
};

/** Autogenerated return type of TimerUnpause. */
export type TimerUnpausePayload = {
  __typename?: 'TimerUnpausePayload';
  errors?: Maybe<Array<Error>>;
  result?: Maybe<Scalars['Boolean']>;
  timer?: Maybe<Timer>;
};

export type TimerUpdateInput = {
  label?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of TimerUpdate. */
export type TimerUpdatePayload = {
  __typename?: 'TimerUpdatePayload';
  errors?: Maybe<Array<Error>>;
  timer?: Maybe<Timer>;
};

export type CreateEventFragment = { __typename?: 'Event', id: string, name: string, slug: string };

export type CreateEventMutationVariables = Exact<{
  input: EventInput;
}>;


export type CreateEventMutation = { __typename?: 'Mutation', eventCreate?: { __typename?: 'EventCreatePayload', event?: { __typename?: 'Event', id: string, name: string, slug: string } | null, errors?: Array<{ __typename?: 'Error', attribute: string, message: string }> | null } | null };

export type CreatePlayerMutationVariables = Exact<{
  eventID: Scalars['ID'];
  input: PlayerInput;
}>;


export type CreatePlayerMutation = { __typename?: 'Mutation', playerCreate?: { __typename?: 'PlayerCreatePayload', player?: { __typename?: 'Player', id: string } | null, errors?: Array<{ __typename?: 'Error', attribute: string, message: string }> | null } | null };

export type CreatePlayerButtonFragment = { __typename?: 'Event', id: string };

export type CreateRoundButtonFragment = { __typename?: 'Event', id: string };

export type PlayersForRoundCreateQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type PlayersForRoundCreateQuery = { __typename?: 'Query', event: { __typename?: 'Event', id: string, players: { __typename?: 'PlayerConnection', nodes: Array<{ __typename?: 'Player', id: string, name: string }> } } };

export type CreateRoundMutationVariables = Exact<{
  eventId: Scalars['ID'];
  input: RoundInput;
}>;


export type CreateRoundMutation = { __typename?: 'Mutation', roundCreate?: { __typename?: 'RoundCreatePayload', round?: { __typename?: 'Round', id: string } | null, errors?: Array<{ __typename?: 'Error', attribute: string, message: string }> | null } | null };

export type EventLayoutFragment = { __typename?: 'Event', name: string, id: string, slug: string, deleted: boolean };

export type EventListFragment = { __typename?: 'EventConnection', nodes: Array<{ __typename?: 'Event', id: string, slug: string, name: string, deleted: boolean }> };

export type EventListItemFragment = { __typename?: 'Event', id: string, name: string, slug: string, deleted: boolean };

export type DeleteEventMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DeleteEventMutation = { __typename?: 'Mutation', eventDelete?: { __typename?: 'EventDeletePayload', success?: boolean | null } | null };

export type RestoreEventMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type RestoreEventMutation = { __typename?: 'Mutation', eventRestore?: { __typename?: 'EventRestorePayload', event?: { __typename?: 'Event', id: string, name: string, slug: string, deleted: boolean } | null } | null };

export type EventNavFragment = { __typename?: 'Event', id: string, slug: string, deleted: boolean };

export type PlayerForImportFragment = { __typename?: 'Player', id: string, name: string, deleted: boolean };

export type SourceEventForImportFragment = { __typename?: 'Event', id: string, name: string, deleted: boolean, players: { __typename?: 'PlayerConnection', nodes: Array<{ __typename?: 'Player', id: string, name: string, deleted: boolean }> } };

export type SourceEventsForImportQueryVariables = Exact<{ [key: string]: never; }>;


export type SourceEventsForImportQuery = { __typename?: 'Query', events: { __typename?: 'EventConnection', nodes: Array<{ __typename?: 'Event', id: string, name: string, deleted: boolean, players: { __typename?: 'PlayerConnection', nodes: Array<{ __typename?: 'Player', id: string, name: string, deleted: boolean }> } }> } };

export type ImportPlayersButtonFragment = { __typename?: 'Event', id: string, allPlayers: { __typename?: 'PlayerConnection', nodes: Array<{ __typename?: 'Player', id: string, name: string, deleted: boolean }> } };

export type ImportPlayersMutationVariables = Exact<{
  input: PlayerImportBulkInput;
}>;


export type ImportPlayersMutation = { __typename?: 'Mutation', playerImportBulk?: { __typename?: 'PlayerImportBulkPayload', event?: { __typename?: 'Event', id: string, allPlayers: { __typename?: 'PlayerConnection', nodes: Array<{ __typename?: 'Player', id: string, name: string, deleted: boolean }> } } | null } | null };

export type MatchCardFragment = { __typename?: 'Match', id: string, table: number, winnerId?: string | null, draw: boolean, player1: { __typename?: 'Player', id: string, name: string, dropped: boolean }, player2?: { __typename?: 'Player', id: string, name: string, dropped: boolean } | null };

export type MatchFormInputPlayerFragment = { __typename?: 'Player', id: string, name: string };

export type PlayerTableFragment = { __typename?: 'Player', id: string, name: string, winsCount: number, drawsCount: number, lossesCount: number, score: number, opponentWinRate: number, paid: boolean, dropped: boolean, deleted: boolean };

export type EditPlayerDropdownItemFragment = { __typename?: 'Player', id: string, name: string, paid: boolean, dropped: boolean };

export type EditPlayerMutationVariables = Exact<{
  id: Scalars['ID'];
  input: PlayerInput;
}>;


export type EditPlayerMutation = { __typename?: 'Mutation', playerUpdate?: { __typename?: 'PlayerUpdatePayload', player?: { __typename?: 'Player', id: string, name: string, paid: boolean, dropped: boolean } | null, errors?: Array<{ __typename?: 'Error', attribute: string, message: string }> | null } | null };

export type PlayerActionsDropdownFragment = { __typename?: 'Player', id: string, paid: boolean, dropped: boolean, deleted: boolean, name: string };

export type PlayerActionsUpdateMutationVariables = Exact<{
  id: Scalars['ID'];
  input: PlayerInput;
}>;


export type PlayerActionsUpdateMutation = { __typename?: 'Mutation', playerUpdate?: { __typename?: 'PlayerUpdatePayload', player?: { __typename?: 'Player', id: string, paid: boolean, dropped: boolean, deleted: boolean, name: string } | null, errors?: Array<{ __typename?: 'Error', attribute: string, message: string }> | null } | null };

export type PlayerActionsDeleteMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type PlayerActionsDeleteMutation = { __typename?: 'Mutation', playerDelete?: { __typename?: 'PlayerDeletePayload', success?: boolean | null, errors?: Array<{ __typename?: 'Error', attribute: string, message: string }> | null } | null };

export type PlayerActionsRestoreMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type PlayerActionsRestoreMutation = { __typename?: 'Mutation', playerRestore?: { __typename?: 'PlayerRestorePayload', player?: { __typename?: 'Player', id: string, paid: boolean, dropped: boolean, deleted: boolean, name: string } | null, errors?: Array<{ __typename?: 'Error', attribute: string, message: string }> | null } | null };

export type PlayerNameWithBadgesFragment = { __typename?: 'Player', id: string, name: string, paid: boolean, dropped: boolean, deleted: boolean };

export type RoundFragment = { __typename?: 'Round', id: string, number: number, isComplete: boolean, matches: Array<{ __typename?: 'Match', id: string, table: number, winnerId?: string | null, draw: boolean, player1: { __typename?: 'Player', id: string, name: string, dropped: boolean }, player2?: { __typename?: 'Player', id: string, name: string, dropped: boolean } | null }> };

export type RoundListItemFragment = { __typename?: 'Round', id: string, number: number, isComplete: boolean, matches: Array<{ __typename?: 'Match', id: string, table: number, winnerId?: string | null, draw: boolean, player1: { __typename?: 'Player', id: string, name: string, paid: boolean, dropped: boolean, deleted: boolean }, player2?: { __typename?: 'Player', id: string, name: string, paid: boolean, dropped: boolean, deleted: boolean } | null }> };

export type EditRoundDropdownItemFragment = { __typename?: 'Round', id: string, number: number, matches: Array<{ __typename?: 'Match', id: string, table: number, winnerId?: string | null, draw: boolean, player1: { __typename?: 'Player', id: string, name: string }, player2?: { __typename?: 'Player', id: string, name: string } | null }> };

export type PlayersForEditRoundQueryVariables = Exact<{
  roundID: Scalars['ID'];
}>;


export type PlayersForEditRoundQuery = { __typename?: 'Query', round: { __typename?: 'Round', id: string, players: Array<{ __typename?: 'Player', id: string, name: string }>, unpairedPlayers: Array<{ __typename?: 'Player', id: string, name: string }> } };

export type UpdateRoundMutationVariables = Exact<{
  roundID: Scalars['ID'];
  roundInput: RoundInput;
}>;


export type UpdateRoundMutation = { __typename?: 'Mutation', roundUpdate?: { __typename?: 'RoundUpdatePayload', round?: { __typename?: 'Round', id: string, number: number, matches: Array<{ __typename?: 'Match', id: string, table: number, winnerId?: string | null, draw: boolean, player1: { __typename?: 'Player', id: string, name: string }, player2?: { __typename?: 'Player', id: string, name: string } | null }> } | null, errors?: Array<{ __typename?: 'Error', attribute: string, message: string }> | null } | null };

export type RoundControlsDropdownFragment = { __typename?: 'Round', id: string, number: number, matches: Array<{ __typename?: 'Match', id: string, table: number, winnerId?: string | null, draw: boolean, player1: { __typename?: 'Player', id: string, name: string }, player2?: { __typename?: 'Player', id: string, name: string } | null }> };

export type DeleteRoundMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DeleteRoundMutation = { __typename?: 'Mutation', roundDelete?: { __typename?: 'RoundDeletePayload', success?: boolean | null, errors?: Array<{ __typename?: 'Error', attribute: string, message: string }> | null } | null };

export type RoundMatchListItemFragment = { __typename?: 'Match', id: string, winnerId?: string | null, draw: boolean, table: number, player1: { __typename?: 'Player', id: string, name: string, paid: boolean, dropped: boolean, deleted: boolean }, player2?: { __typename?: 'Player', id: string, name: string, paid: boolean, dropped: boolean, deleted: boolean } | null };

export type RoundMatchListFragment = { __typename?: 'Round', isComplete: boolean, matches: Array<{ __typename?: 'Match', id: string, winnerId?: string | null, draw: boolean, table: number, player1: { __typename?: 'Player', id: string, name: string, paid: boolean, dropped: boolean, deleted: boolean }, player2?: { __typename?: 'Player', id: string, name: string, paid: boolean, dropped: boolean, deleted: boolean } | null }> };

export type GeneratePairingsMutationVariables = Exact<{
  eventId: Scalars['ID'];
  playerIds: Array<Scalars['ID']> | Scalars['ID'];
}>;


export type GeneratePairingsMutation = { __typename?: 'Mutation', eventGeneratePairings?: { __typename?: 'EventGeneratePairingsPayload', pairings: Array<{ __typename?: 'Pairing', player1: { __typename?: 'Player', id: string, name: string }, player2?: { __typename?: 'Player', id: string, name: string } | null }> } | null };

export type SlipEventFragment = { __typename?: 'Event', id: string, name: string };

export type SlipRoundFragment = { __typename?: 'Round', id: string, number: number };

export type SlipMatchFragment = { __typename?: 'Match', id: string, winnerId?: string | null, draw: boolean, table: number, player1: { __typename?: 'Player', id: string, name: string, score: number }, player2?: { __typename?: 'Player', id: string, name: string, score: number } | null };

export type TimerListItemFragment = { __typename?: 'Timer', id: string, label?: string | null, instant: any, isExpired: boolean, expiresAt: any, isPaused: boolean, pausedAt?: any | null, totalDurationInSeconds: number, phases: Array<{ __typename?: 'TimerPhase', id: string, name: string, position: number, durationInSeconds: number, offsetFromStart: number, offsetFromEnd: number, audioClip?: { __typename?: 'AudioClip', id: string, fileUrl: string } | null }> };

export type TimerPresetSelectFragment = { __typename?: 'TimerPreset', id: string, name: string, phasesCount: number, totalDurationInSeconds: number };

export type ErrorsFragment = { __typename?: 'Error', attribute: string, message: string };

export type EventShowQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type EventShowQuery = { __typename?: 'Query', event: { __typename?: 'Event', id: string, name: string, slug: string, deleted: boolean } };

export type EventExportQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type EventExportQuery = { __typename?: 'Query', event: { __typename?: 'Event', id: string, name: string, slug: string, deleted: boolean, players: { __typename?: 'PlayerConnection', nodes: Array<{ __typename?: 'Player', id: string, name: string, score: number, winsCount: number, lossesCount: number, drawsCount: number, opponentWinRate: number }> }, rounds: Array<{ __typename?: 'Round', id: string, number: number, matches: Array<{ __typename?: 'Match', id: string, table: number, player1: { __typename?: 'Player', id: string, name: string, winsCount: number, lossesCount: number, drawsCount: number }, player2?: { __typename?: 'Player', id: string, name: string, winsCount: number, lossesCount: number, drawsCount: number } | null }> }> } };

export type EventMatchesQueryVariables = Exact<{
  id: Scalars['ID'];
  deleted?: InputMaybe<DeletedFilter>;
}>;


export type EventMatchesQuery = { __typename?: 'Query', event: { __typename?: 'Event', id: string, name: string, slug: string, deleted: boolean, rounds: Array<{ __typename?: 'Round', id: string, number: number, isComplete: boolean, matches: Array<{ __typename?: 'Match', id: string, table: number, winnerId?: string | null, draw: boolean, player1: { __typename?: 'Player', id: string, name: string, dropped: boolean, paid: boolean, deleted: boolean }, player2?: { __typename?: 'Player', id: string, name: string, dropped: boolean, paid: boolean, deleted: boolean } | null }> }>, players: { __typename?: 'PlayerConnection', totalCount: number } } };

export type SetMatchResolutionMutationVariables = Exact<{
  id: Scalars['ID'];
  winnerId?: InputMaybe<Scalars['ID']>;
  draw: Scalars['Boolean'];
}>;


export type SetMatchResolutionMutation = { __typename?: 'Mutation', matchUpdate?: { __typename?: 'MatchUpdatePayload', match?: { __typename?: 'Match', id: string, winnerId?: string | null, draw: boolean, round: { __typename?: 'Round', id: string, isComplete: boolean } } | null, errors?: Array<{ __typename?: 'Error', attribute: string, message: string }> | null } | null };

export type EventPlayersQueryVariables = Exact<{
  id: Scalars['ID'];
  deleted?: InputMaybe<DeletedFilter>;
}>;


export type EventPlayersQuery = { __typename?: 'Query', event: { __typename?: 'Event', id: string, name: string, slug: string, deleted: boolean, players: { __typename?: 'PlayerConnection', nodes: Array<{ __typename?: 'Player', id: string, name: string, winsCount: number, drawsCount: number, lossesCount: number, score: number, opponentWinRate: number, paid: boolean, dropped: boolean, deleted: boolean }> }, allPlayers: { __typename?: 'PlayerConnection', nodes: Array<{ __typename?: 'Player', id: string, name: string, deleted: boolean }> } } };

export type EventSlipsQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type EventSlipsQuery = { __typename?: 'Query', event: { __typename?: 'Event', id: string, name: string, slug: string, deleted: boolean, rounds: Array<{ __typename?: 'Round', id: string, number: number, matches: Array<{ __typename?: 'Match', id: string, winnerId?: string | null, draw: boolean, table: number, player1: { __typename?: 'Player', id: string, name: string, score: number }, player2?: { __typename?: 'Player', id: string, name: string, score: number } | null }> }> } };

export type TimerFragment = { __typename?: 'Timer', id: string, label?: string | null, instant: any, isExpired: boolean, expiresAt: any, isPaused: boolean, pausedAt?: any | null, totalDurationInSeconds: number, phases: Array<{ __typename?: 'TimerPhase', id: string, name: string, position: number, durationInSeconds: number, offsetFromStart: number, offsetFromEnd: number, audioClip?: { __typename?: 'AudioClip', id: string, fileUrl: string } | null }> };

export type EventTimersQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type EventTimersQuery = { __typename?: 'Query', event: { __typename?: 'Event', id: string, name: string, slug: string, deleted: boolean, timers: Array<{ __typename?: 'Timer', id: string, label?: string | null, instant: any, isExpired: boolean, expiresAt: any, isPaused: boolean, pausedAt?: any | null, totalDurationInSeconds: number, phases: Array<{ __typename?: 'TimerPhase', id: string, name: string, position: number, durationInSeconds: number, offsetFromStart: number, offsetFromEnd: number, audioClip?: { __typename?: 'AudioClip', id: string, fileUrl: string } | null }> }> }, timerPresets: { __typename?: 'TimerPresetConnection', nodes: Array<{ __typename?: 'TimerPreset', id: string, name: string, phasesCount: number, totalDurationInSeconds: number }> } };

export type TimerEventSubscriptionVariables = Exact<{
  eventId: Scalars['ID'];
}>;


export type TimerEventSubscription = { __typename?: 'Subscription', timerEvent: { __typename?: 'TimerEventPayload', eventType?: TimerEventType | null, timer?: { __typename?: 'Timer', id: string, label?: string | null, instant: any, isExpired: boolean, expiresAt: any, isPaused: boolean, pausedAt?: any | null, totalDurationInSeconds: number, phases: Array<{ __typename?: 'TimerPhase', id: string, name: string, position: number, durationInSeconds: number, offsetFromStart: number, offsetFromEnd: number, audioClip?: { __typename?: 'AudioClip', id: string, fileUrl: string } | null }> } | null } };

export type TimerDeletedSubscriptionVariables = Exact<{
  eventId: Scalars['ID'];
}>;


export type TimerDeletedSubscription = { __typename?: 'Subscription', timerDeleted: { __typename?: 'TimerDeletedPayload', timerId: string } };

export type CreateTimerMutationVariables = Exact<{
  eventId: Scalars['ID'];
  input: TimerCreateInput;
}>;


export type CreateTimerMutation = { __typename?: 'Mutation', timerCreate?: { __typename?: 'TimerCreatePayload', timer?: { __typename?: 'Timer', id: string, label?: string | null, instant: any, isExpired: boolean, expiresAt: any, isPaused: boolean, pausedAt?: any | null, totalDurationInSeconds: number, phases: Array<{ __typename?: 'TimerPhase', id: string, name: string, position: number, durationInSeconds: number, offsetFromStart: number, offsetFromEnd: number, audioClip?: { __typename?: 'AudioClip', id: string, fileUrl: string } | null }> } | null } | null };

export type UpdateTimerMutationVariables = Exact<{
  id: Scalars['ID'];
  input: TimerUpdateInput;
}>;


export type UpdateTimerMutation = { __typename?: 'Mutation', timerUpdate?: { __typename?: 'TimerUpdatePayload', timer?: { __typename?: 'Timer', id: string, label?: string | null, instant: any, isExpired: boolean, expiresAt: any, isPaused: boolean, pausedAt?: any | null, totalDurationInSeconds: number, phases: Array<{ __typename?: 'TimerPhase', id: string, name: string, position: number, durationInSeconds: number, offsetFromStart: number, offsetFromEnd: number, audioClip?: { __typename?: 'AudioClip', id: string, fileUrl: string } | null }> } | null } | null };

export type DeleteTimerMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DeleteTimerMutation = { __typename?: 'Mutation', timerDelete?: { __typename?: 'TimerDeletePayload', success?: boolean | null } | null };

export type PauseTimerMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type PauseTimerMutation = { __typename?: 'Mutation', timerPause?: { __typename?: 'TimerPausePayload', timer?: { __typename?: 'Timer', id: string, label?: string | null, instant: any, isExpired: boolean, expiresAt: any, isPaused: boolean, pausedAt?: any | null, totalDurationInSeconds: number, phases: Array<{ __typename?: 'TimerPhase', id: string, name: string, position: number, durationInSeconds: number, offsetFromStart: number, offsetFromEnd: number, audioClip?: { __typename?: 'AudioClip', id: string, fileUrl: string } | null }> } | null } | null };

export type UnpauseTimerMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type UnpauseTimerMutation = { __typename?: 'Mutation', timerUnpause?: { __typename?: 'TimerUnpausePayload', timer?: { __typename?: 'Timer', id: string, label?: string | null, instant: any, isExpired: boolean, expiresAt: any, isPaused: boolean, pausedAt?: any | null, totalDurationInSeconds: number, phases: Array<{ __typename?: 'TimerPhase', id: string, name: string, position: number, durationInSeconds: number, offsetFromStart: number, offsetFromEnd: number, audioClip?: { __typename?: 'AudioClip', id: string, fileUrl: string } | null }> } | null } | null };

export type SkipTimerToNextPhaseMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type SkipTimerToNextPhaseMutation = { __typename?: 'Mutation', timerSkipToNextPhase?: { __typename?: 'TimerSkipToNextPhasePayload', timer?: { __typename?: 'Timer', id: string, label?: string | null, instant: any, isExpired: boolean, expiresAt: any, isPaused: boolean, pausedAt?: any | null, totalDurationInSeconds: number, phases: Array<{ __typename?: 'TimerPhase', id: string, name: string, position: number, durationInSeconds: number, offsetFromStart: number, offsetFromEnd: number, audioClip?: { __typename?: 'AudioClip', id: string, fileUrl: string } | null }> } | null } | null };

export type CloneTimerWithOffsetMutationVariables = Exact<{
  id: Scalars['ID'];
  input: TimerCloneWithOffsetInput;
}>;


export type CloneTimerWithOffsetMutation = { __typename?: 'Mutation', timerCloneWithOffset?: { __typename?: 'TimerCloneWithOffsetPayload', timer?: { __typename?: 'Timer', id: string, label?: string | null, instant: any, isExpired: boolean, expiresAt: any, isPaused: boolean, pausedAt?: any | null, totalDurationInSeconds: number, phases: Array<{ __typename?: 'TimerPhase', id: string, name: string, position: number, durationInSeconds: number, offsetFromStart: number, offsetFromEnd: number, audioClip?: { __typename?: 'AudioClip', id: string, fileUrl: string } | null }> } | null } | null };

export type ResetTimerMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type ResetTimerMutation = { __typename?: 'Mutation', timerReset?: { __typename?: 'TimerResetPayload', timer?: { __typename?: 'Timer', id: string, label?: string | null, instant: any, isExpired: boolean, expiresAt: any, isPaused: boolean, pausedAt?: any | null, totalDurationInSeconds: number, phases: Array<{ __typename?: 'TimerPhase', id: string, name: string, position: number, durationInSeconds: number, offsetFromStart: number, offsetFromEnd: number, audioClip?: { __typename?: 'AudioClip', id: string, fileUrl: string } | null }> } | null } | null };

export type EventsIndexQueryVariables = Exact<{
  deleted?: InputMaybe<DeletedFilter>;
}>;


export type EventsIndexQuery = { __typename?: 'Query', events: { __typename?: 'EventConnection', nodes: Array<{ __typename?: 'Event', id: string, slug: string, name: string, deleted: boolean }> } };

export const CreateEventFragmentDoc = gql`
    fragment CreateEvent on Event {
  id
  name
  slug
}
    `;
export const CreatePlayerButtonFragmentDoc = gql`
    fragment CreatePlayerButton on Event {
  id
}
    `;
export const CreateRoundButtonFragmentDoc = gql`
    fragment CreateRoundButton on Event {
  id
}
    `;
export const EventNavFragmentDoc = gql`
    fragment EventNav on Event {
  id
  slug
  deleted
}
    `;
export const EventLayoutFragmentDoc = gql`
    fragment EventLayout on Event {
  name
  ...EventNav
}
    ${EventNavFragmentDoc}`;
export const EventListItemFragmentDoc = gql`
    fragment EventListItem on Event {
  id
  name
  slug
  deleted
}
    `;
export const EventListFragmentDoc = gql`
    fragment EventList on EventConnection {
  nodes {
    id
    slug
    ...EventListItem
  }
}
    ${EventListItemFragmentDoc}`;
export const PlayerForImportFragmentDoc = gql`
    fragment PlayerForImport on Player {
  id
  name
  deleted
}
    `;
export const SourceEventForImportFragmentDoc = gql`
    fragment SourceEventForImport on Event {
  id
  name
  deleted
  players {
    nodes {
      ...PlayerForImport
    }
  }
}
    ${PlayerForImportFragmentDoc}`;
export const ImportPlayersButtonFragmentDoc = gql`
    fragment ImportPlayersButton on Event {
  id
  allPlayers: players {
    nodes {
      id
      name
      deleted
    }
  }
}
    `;
export const PlayerNameWithBadgesFragmentDoc = gql`
    fragment PlayerNameWithBadges on Player {
  id
  name
  paid
  dropped
  deleted
}
    `;
export const EditPlayerDropdownItemFragmentDoc = gql`
    fragment EditPlayerDropdownItem on Player {
  id
  name
  paid
  dropped
}
    `;
export const PlayerActionsDropdownFragmentDoc = gql`
    fragment PlayerActionsDropdown on Player {
  id
  paid
  dropped
  deleted
  ...EditPlayerDropdownItem
}
    ${EditPlayerDropdownItemFragmentDoc}`;
export const PlayerTableFragmentDoc = gql`
    fragment PlayerTable on Player {
  id
  name
  winsCount
  drawsCount
  lossesCount
  score
  opponentWinRate
  ...PlayerNameWithBadges
  ...PlayerActionsDropdown
}
    ${PlayerNameWithBadgesFragmentDoc}
${PlayerActionsDropdownFragmentDoc}`;
export const MatchCardFragmentDoc = gql`
    fragment MatchCard on Match {
  id
  table
  winnerId
  draw
  player1 {
    id
    name
    dropped
  }
  player2 {
    id
    name
    dropped
  }
}
    `;
export const MatchFormInputPlayerFragmentDoc = gql`
    fragment MatchFormInputPlayer on Player {
  id
  name
}
    `;
export const EditRoundDropdownItemFragmentDoc = gql`
    fragment EditRoundDropdownItem on Round {
  id
  number
  matches {
    id
    table
    winnerId
    draw
    player1 {
      id
      ...MatchFormInputPlayer
    }
    player2 {
      id
      ...MatchFormInputPlayer
    }
  }
}
    ${MatchFormInputPlayerFragmentDoc}`;
export const RoundFragmentDoc = gql`
    fragment Round on Round {
  id
  number
  isComplete
  matches {
    ...MatchCard
  }
  ...EditRoundDropdownItem
}
    ${MatchCardFragmentDoc}
${EditRoundDropdownItemFragmentDoc}`;
export const RoundControlsDropdownFragmentDoc = gql`
    fragment RoundControlsDropdown on Round {
  id
  ...EditRoundDropdownItem
}
    ${EditRoundDropdownItemFragmentDoc}`;
export const RoundMatchListItemFragmentDoc = gql`
    fragment RoundMatchListItem on Match {
  id
  player1 {
    id
    ...PlayerNameWithBadges
  }
  player2 {
    id
    ...PlayerNameWithBadges
  }
  winnerId
  draw
  table
}
    ${PlayerNameWithBadgesFragmentDoc}`;
export const RoundMatchListFragmentDoc = gql`
    fragment RoundMatchList on Round {
  isComplete
  matches {
    ...RoundMatchListItem
  }
}
    ${RoundMatchListItemFragmentDoc}`;
export const RoundListItemFragmentDoc = gql`
    fragment RoundListItem on Round {
  id
  number
  ...RoundControlsDropdown
  ...RoundMatchList
}
    ${RoundControlsDropdownFragmentDoc}
${RoundMatchListFragmentDoc}`;
export const SlipEventFragmentDoc = gql`
    fragment SlipEvent on Event {
  id
  name
}
    `;
export const SlipRoundFragmentDoc = gql`
    fragment SlipRound on Round {
  id
  number
}
    `;
export const SlipMatchFragmentDoc = gql`
    fragment SlipMatch on Match {
  id
  player1 {
    id
    name
    score
  }
  player2 {
    id
    name
    score
  }
  winnerId
  draw
  table
}
    `;
export const TimerPresetSelectFragmentDoc = gql`
    fragment TimerPresetSelect on TimerPreset {
  id
  name
  phasesCount
  totalDurationInSeconds
}
    `;
export const ErrorsFragmentDoc = gql`
    fragment Errors on Error {
  attribute
  message(full: true)
}
    `;
export const TimerListItemFragmentDoc = gql`
    fragment TimerListItem on Timer {
  id
  label
  instant
  isExpired
  expiresAt
  isPaused
  pausedAt
  totalDurationInSeconds
  phases {
    id
    name
    position
    durationInSeconds
    offsetFromStart
    offsetFromEnd
    audioClip {
      id
      fileUrl
    }
  }
}
    `;
export const TimerFragmentDoc = gql`
    fragment Timer on Timer {
  ...TimerListItem
}
    ${TimerListItemFragmentDoc}`;
export const CreateEventDocument = gql`
    mutation CreateEvent($input: EventInput!) {
  eventCreate(input: $input) {
    event {
      ...CreateEvent
    }
    errors {
      ...Errors
    }
  }
}
    ${CreateEventFragmentDoc}
${ErrorsFragmentDoc}`;
export type CreateEventMutationFn = Apollo.MutationFunction<CreateEventMutation, CreateEventMutationVariables>;

/**
 * __useCreateEventMutation__
 *
 * To run a mutation, you first call `useCreateEventMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateEventMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createEventMutation, { data, loading, error }] = useCreateEventMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateEventMutation(baseOptions?: Apollo.MutationHookOptions<CreateEventMutation, CreateEventMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateEventMutation, CreateEventMutationVariables>(CreateEventDocument, options);
      }
export type CreateEventMutationHookResult = ReturnType<typeof useCreateEventMutation>;
export type CreateEventMutationResult = Apollo.MutationResult<CreateEventMutation>;
export type CreateEventMutationOptions = Apollo.BaseMutationOptions<CreateEventMutation, CreateEventMutationVariables>;
export const CreatePlayerDocument = gql`
    mutation CreatePlayer($eventID: ID!, $input: PlayerInput!) {
  playerCreate(eventId: $eventID, input: $input) {
    player {
      id
    }
    errors {
      ...Errors
    }
  }
}
    ${ErrorsFragmentDoc}`;
export type CreatePlayerMutationFn = Apollo.MutationFunction<CreatePlayerMutation, CreatePlayerMutationVariables>;

/**
 * __useCreatePlayerMutation__
 *
 * To run a mutation, you first call `useCreatePlayerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePlayerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPlayerMutation, { data, loading, error }] = useCreatePlayerMutation({
 *   variables: {
 *      eventID: // value for 'eventID'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreatePlayerMutation(baseOptions?: Apollo.MutationHookOptions<CreatePlayerMutation, CreatePlayerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreatePlayerMutation, CreatePlayerMutationVariables>(CreatePlayerDocument, options);
      }
export type CreatePlayerMutationHookResult = ReturnType<typeof useCreatePlayerMutation>;
export type CreatePlayerMutationResult = Apollo.MutationResult<CreatePlayerMutation>;
export type CreatePlayerMutationOptions = Apollo.BaseMutationOptions<CreatePlayerMutation, CreatePlayerMutationVariables>;
export const PlayersForRoundCreateDocument = gql`
    query PlayersForRoundCreate($id: ID!) {
  event(id: $id) {
    id
    players(activeOnly: true) {
      nodes {
        id
        ...MatchFormInputPlayer
      }
    }
  }
}
    ${MatchFormInputPlayerFragmentDoc}`;

/**
 * __usePlayersForRoundCreateQuery__
 *
 * To run a query within a React component, call `usePlayersForRoundCreateQuery` and pass it any options that fit your needs.
 * When your component renders, `usePlayersForRoundCreateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePlayersForRoundCreateQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePlayersForRoundCreateQuery(baseOptions: Apollo.QueryHookOptions<PlayersForRoundCreateQuery, PlayersForRoundCreateQueryVariables> & ({ variables: PlayersForRoundCreateQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PlayersForRoundCreateQuery, PlayersForRoundCreateQueryVariables>(PlayersForRoundCreateDocument, options);
      }
export function usePlayersForRoundCreateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PlayersForRoundCreateQuery, PlayersForRoundCreateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PlayersForRoundCreateQuery, PlayersForRoundCreateQueryVariables>(PlayersForRoundCreateDocument, options);
        }
export function usePlayersForRoundCreateSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<PlayersForRoundCreateQuery, PlayersForRoundCreateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PlayersForRoundCreateQuery, PlayersForRoundCreateQueryVariables>(PlayersForRoundCreateDocument, options);
        }
export type PlayersForRoundCreateQueryHookResult = ReturnType<typeof usePlayersForRoundCreateQuery>;
export type PlayersForRoundCreateLazyQueryHookResult = ReturnType<typeof usePlayersForRoundCreateLazyQuery>;
export type PlayersForRoundCreateSuspenseQueryHookResult = ReturnType<typeof usePlayersForRoundCreateSuspenseQuery>;
export type PlayersForRoundCreateQueryResult = Apollo.QueryResult<PlayersForRoundCreateQuery, PlayersForRoundCreateQueryVariables>;
export const CreateRoundDocument = gql`
    mutation CreateRound($eventId: ID!, $input: RoundInput!) {
  roundCreate(eventId: $eventId, input: $input) {
    round {
      id
    }
    errors {
      ...Errors
    }
  }
}
    ${ErrorsFragmentDoc}`;
export type CreateRoundMutationFn = Apollo.MutationFunction<CreateRoundMutation, CreateRoundMutationVariables>;

/**
 * __useCreateRoundMutation__
 *
 * To run a mutation, you first call `useCreateRoundMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateRoundMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createRoundMutation, { data, loading, error }] = useCreateRoundMutation({
 *   variables: {
 *      eventId: // value for 'eventId'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateRoundMutation(baseOptions?: Apollo.MutationHookOptions<CreateRoundMutation, CreateRoundMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateRoundMutation, CreateRoundMutationVariables>(CreateRoundDocument, options);
      }
export type CreateRoundMutationHookResult = ReturnType<typeof useCreateRoundMutation>;
export type CreateRoundMutationResult = Apollo.MutationResult<CreateRoundMutation>;
export type CreateRoundMutationOptions = Apollo.BaseMutationOptions<CreateRoundMutation, CreateRoundMutationVariables>;
export const DeleteEventDocument = gql`
    mutation DeleteEvent($id: ID!) {
  eventDelete(id: $id) {
    success
  }
}
    `;
export type DeleteEventMutationFn = Apollo.MutationFunction<DeleteEventMutation, DeleteEventMutationVariables>;

/**
 * __useDeleteEventMutation__
 *
 * To run a mutation, you first call `useDeleteEventMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteEventMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteEventMutation, { data, loading, error }] = useDeleteEventMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteEventMutation(baseOptions?: Apollo.MutationHookOptions<DeleteEventMutation, DeleteEventMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteEventMutation, DeleteEventMutationVariables>(DeleteEventDocument, options);
      }
export type DeleteEventMutationHookResult = ReturnType<typeof useDeleteEventMutation>;
export type DeleteEventMutationResult = Apollo.MutationResult<DeleteEventMutation>;
export type DeleteEventMutationOptions = Apollo.BaseMutationOptions<DeleteEventMutation, DeleteEventMutationVariables>;
export const RestoreEventDocument = gql`
    mutation RestoreEvent($id: ID!) {
  eventRestore(id: $id) {
    event {
      id
      ...EventListItem
    }
  }
}
    ${EventListItemFragmentDoc}`;
export type RestoreEventMutationFn = Apollo.MutationFunction<RestoreEventMutation, RestoreEventMutationVariables>;

/**
 * __useRestoreEventMutation__
 *
 * To run a mutation, you first call `useRestoreEventMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRestoreEventMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [restoreEventMutation, { data, loading, error }] = useRestoreEventMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRestoreEventMutation(baseOptions?: Apollo.MutationHookOptions<RestoreEventMutation, RestoreEventMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RestoreEventMutation, RestoreEventMutationVariables>(RestoreEventDocument, options);
      }
export type RestoreEventMutationHookResult = ReturnType<typeof useRestoreEventMutation>;
export type RestoreEventMutationResult = Apollo.MutationResult<RestoreEventMutation>;
export type RestoreEventMutationOptions = Apollo.BaseMutationOptions<RestoreEventMutation, RestoreEventMutationVariables>;
export const SourceEventsForImportDocument = gql`
    query SourceEventsForImport {
  events {
    nodes {
      ...SourceEventForImport
    }
  }
}
    ${SourceEventForImportFragmentDoc}`;

/**
 * __useSourceEventsForImportQuery__
 *
 * To run a query within a React component, call `useSourceEventsForImportQuery` and pass it any options that fit your needs.
 * When your component renders, `useSourceEventsForImportQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSourceEventsForImportQuery({
 *   variables: {
 *   },
 * });
 */
export function useSourceEventsForImportQuery(baseOptions?: Apollo.QueryHookOptions<SourceEventsForImportQuery, SourceEventsForImportQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SourceEventsForImportQuery, SourceEventsForImportQueryVariables>(SourceEventsForImportDocument, options);
      }
export function useSourceEventsForImportLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SourceEventsForImportQuery, SourceEventsForImportQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SourceEventsForImportQuery, SourceEventsForImportQueryVariables>(SourceEventsForImportDocument, options);
        }
export function useSourceEventsForImportSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<SourceEventsForImportQuery, SourceEventsForImportQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SourceEventsForImportQuery, SourceEventsForImportQueryVariables>(SourceEventsForImportDocument, options);
        }
export type SourceEventsForImportQueryHookResult = ReturnType<typeof useSourceEventsForImportQuery>;
export type SourceEventsForImportLazyQueryHookResult = ReturnType<typeof useSourceEventsForImportLazyQuery>;
export type SourceEventsForImportSuspenseQueryHookResult = ReturnType<typeof useSourceEventsForImportSuspenseQuery>;
export type SourceEventsForImportQueryResult = Apollo.QueryResult<SourceEventsForImportQuery, SourceEventsForImportQueryVariables>;
export const ImportPlayersDocument = gql`
    mutation ImportPlayers($input: PlayerImportBulkInput!) {
  playerImportBulk(input: $input) {
    event {
      id
      ...ImportPlayersButton
    }
  }
}
    ${ImportPlayersButtonFragmentDoc}`;
export type ImportPlayersMutationFn = Apollo.MutationFunction<ImportPlayersMutation, ImportPlayersMutationVariables>;

/**
 * __useImportPlayersMutation__
 *
 * To run a mutation, you first call `useImportPlayersMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useImportPlayersMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [importPlayersMutation, { data, loading, error }] = useImportPlayersMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useImportPlayersMutation(baseOptions?: Apollo.MutationHookOptions<ImportPlayersMutation, ImportPlayersMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ImportPlayersMutation, ImportPlayersMutationVariables>(ImportPlayersDocument, options);
      }
export type ImportPlayersMutationHookResult = ReturnType<typeof useImportPlayersMutation>;
export type ImportPlayersMutationResult = Apollo.MutationResult<ImportPlayersMutation>;
export type ImportPlayersMutationOptions = Apollo.BaseMutationOptions<ImportPlayersMutation, ImportPlayersMutationVariables>;
export const EditPlayerDocument = gql`
    mutation EditPlayer($id: ID!, $input: PlayerInput!) {
  playerUpdate(id: $id, input: $input) {
    player {
      id
      ...EditPlayerDropdownItem
    }
    errors {
      ...Errors
    }
  }
}
    ${EditPlayerDropdownItemFragmentDoc}
${ErrorsFragmentDoc}`;
export type EditPlayerMutationFn = Apollo.MutationFunction<EditPlayerMutation, EditPlayerMutationVariables>;

/**
 * __useEditPlayerMutation__
 *
 * To run a mutation, you first call `useEditPlayerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditPlayerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editPlayerMutation, { data, loading, error }] = useEditPlayerMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useEditPlayerMutation(baseOptions?: Apollo.MutationHookOptions<EditPlayerMutation, EditPlayerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EditPlayerMutation, EditPlayerMutationVariables>(EditPlayerDocument, options);
      }
export type EditPlayerMutationHookResult = ReturnType<typeof useEditPlayerMutation>;
export type EditPlayerMutationResult = Apollo.MutationResult<EditPlayerMutation>;
export type EditPlayerMutationOptions = Apollo.BaseMutationOptions<EditPlayerMutation, EditPlayerMutationVariables>;
export const PlayerActionsUpdateDocument = gql`
    mutation PlayerActionsUpdate($id: ID!, $input: PlayerInput!) {
  playerUpdate(id: $id, input: $input) {
    player {
      id
      ...PlayerActionsDropdown
    }
    errors {
      attribute
      message
    }
  }
}
    ${PlayerActionsDropdownFragmentDoc}`;
export type PlayerActionsUpdateMutationFn = Apollo.MutationFunction<PlayerActionsUpdateMutation, PlayerActionsUpdateMutationVariables>;

/**
 * __usePlayerActionsUpdateMutation__
 *
 * To run a mutation, you first call `usePlayerActionsUpdateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePlayerActionsUpdateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [playerActionsUpdateMutation, { data, loading, error }] = usePlayerActionsUpdateMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function usePlayerActionsUpdateMutation(baseOptions?: Apollo.MutationHookOptions<PlayerActionsUpdateMutation, PlayerActionsUpdateMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PlayerActionsUpdateMutation, PlayerActionsUpdateMutationVariables>(PlayerActionsUpdateDocument, options);
      }
export type PlayerActionsUpdateMutationHookResult = ReturnType<typeof usePlayerActionsUpdateMutation>;
export type PlayerActionsUpdateMutationResult = Apollo.MutationResult<PlayerActionsUpdateMutation>;
export type PlayerActionsUpdateMutationOptions = Apollo.BaseMutationOptions<PlayerActionsUpdateMutation, PlayerActionsUpdateMutationVariables>;
export const PlayerActionsDeleteDocument = gql`
    mutation PlayerActionsDelete($id: ID!) {
  playerDelete(id: $id) {
    success
    errors {
      attribute
      message
    }
  }
}
    `;
export type PlayerActionsDeleteMutationFn = Apollo.MutationFunction<PlayerActionsDeleteMutation, PlayerActionsDeleteMutationVariables>;

/**
 * __usePlayerActionsDeleteMutation__
 *
 * To run a mutation, you first call `usePlayerActionsDeleteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePlayerActionsDeleteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [playerActionsDeleteMutation, { data, loading, error }] = usePlayerActionsDeleteMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePlayerActionsDeleteMutation(baseOptions?: Apollo.MutationHookOptions<PlayerActionsDeleteMutation, PlayerActionsDeleteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PlayerActionsDeleteMutation, PlayerActionsDeleteMutationVariables>(PlayerActionsDeleteDocument, options);
      }
export type PlayerActionsDeleteMutationHookResult = ReturnType<typeof usePlayerActionsDeleteMutation>;
export type PlayerActionsDeleteMutationResult = Apollo.MutationResult<PlayerActionsDeleteMutation>;
export type PlayerActionsDeleteMutationOptions = Apollo.BaseMutationOptions<PlayerActionsDeleteMutation, PlayerActionsDeleteMutationVariables>;
export const PlayerActionsRestoreDocument = gql`
    mutation PlayerActionsRestore($id: ID!) {
  playerRestore(id: $id) {
    player {
      id
      ...PlayerActionsDropdown
    }
    errors {
      attribute
      message
    }
  }
}
    ${PlayerActionsDropdownFragmentDoc}`;
export type PlayerActionsRestoreMutationFn = Apollo.MutationFunction<PlayerActionsRestoreMutation, PlayerActionsRestoreMutationVariables>;

/**
 * __usePlayerActionsRestoreMutation__
 *
 * To run a mutation, you first call `usePlayerActionsRestoreMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePlayerActionsRestoreMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [playerActionsRestoreMutation, { data, loading, error }] = usePlayerActionsRestoreMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePlayerActionsRestoreMutation(baseOptions?: Apollo.MutationHookOptions<PlayerActionsRestoreMutation, PlayerActionsRestoreMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PlayerActionsRestoreMutation, PlayerActionsRestoreMutationVariables>(PlayerActionsRestoreDocument, options);
      }
export type PlayerActionsRestoreMutationHookResult = ReturnType<typeof usePlayerActionsRestoreMutation>;
export type PlayerActionsRestoreMutationResult = Apollo.MutationResult<PlayerActionsRestoreMutation>;
export type PlayerActionsRestoreMutationOptions = Apollo.BaseMutationOptions<PlayerActionsRestoreMutation, PlayerActionsRestoreMutationVariables>;
export const PlayersForEditRoundDocument = gql`
    query PlayersForEditRound($roundID: ID!) {
  round(id: $roundID) {
    id
    players(deleted: ALL) {
      id
      ...MatchFormInputPlayer
    }
    unpairedPlayers(activeOnly: true, deleted: NON_DELETED) {
      id
      ...MatchFormInputPlayer
    }
  }
}
    ${MatchFormInputPlayerFragmentDoc}`;

/**
 * __usePlayersForEditRoundQuery__
 *
 * To run a query within a React component, call `usePlayersForEditRoundQuery` and pass it any options that fit your needs.
 * When your component renders, `usePlayersForEditRoundQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePlayersForEditRoundQuery({
 *   variables: {
 *      roundID: // value for 'roundID'
 *   },
 * });
 */
export function usePlayersForEditRoundQuery(baseOptions: Apollo.QueryHookOptions<PlayersForEditRoundQuery, PlayersForEditRoundQueryVariables> & ({ variables: PlayersForEditRoundQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PlayersForEditRoundQuery, PlayersForEditRoundQueryVariables>(PlayersForEditRoundDocument, options);
      }
export function usePlayersForEditRoundLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PlayersForEditRoundQuery, PlayersForEditRoundQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PlayersForEditRoundQuery, PlayersForEditRoundQueryVariables>(PlayersForEditRoundDocument, options);
        }
export function usePlayersForEditRoundSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<PlayersForEditRoundQuery, PlayersForEditRoundQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PlayersForEditRoundQuery, PlayersForEditRoundQueryVariables>(PlayersForEditRoundDocument, options);
        }
export type PlayersForEditRoundQueryHookResult = ReturnType<typeof usePlayersForEditRoundQuery>;
export type PlayersForEditRoundLazyQueryHookResult = ReturnType<typeof usePlayersForEditRoundLazyQuery>;
export type PlayersForEditRoundSuspenseQueryHookResult = ReturnType<typeof usePlayersForEditRoundSuspenseQuery>;
export type PlayersForEditRoundQueryResult = Apollo.QueryResult<PlayersForEditRoundQuery, PlayersForEditRoundQueryVariables>;
export const UpdateRoundDocument = gql`
    mutation UpdateRound($roundID: ID!, $roundInput: RoundInput!) {
  roundUpdate(id: $roundID, input: $roundInput) {
    round {
      id
      ...EditRoundDropdownItem
    }
    errors {
      ...Errors
    }
  }
}
    ${EditRoundDropdownItemFragmentDoc}
${ErrorsFragmentDoc}`;
export type UpdateRoundMutationFn = Apollo.MutationFunction<UpdateRoundMutation, UpdateRoundMutationVariables>;

/**
 * __useUpdateRoundMutation__
 *
 * To run a mutation, you first call `useUpdateRoundMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateRoundMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateRoundMutation, { data, loading, error }] = useUpdateRoundMutation({
 *   variables: {
 *      roundID: // value for 'roundID'
 *      roundInput: // value for 'roundInput'
 *   },
 * });
 */
export function useUpdateRoundMutation(baseOptions?: Apollo.MutationHookOptions<UpdateRoundMutation, UpdateRoundMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateRoundMutation, UpdateRoundMutationVariables>(UpdateRoundDocument, options);
      }
export type UpdateRoundMutationHookResult = ReturnType<typeof useUpdateRoundMutation>;
export type UpdateRoundMutationResult = Apollo.MutationResult<UpdateRoundMutation>;
export type UpdateRoundMutationOptions = Apollo.BaseMutationOptions<UpdateRoundMutation, UpdateRoundMutationVariables>;
export const DeleteRoundDocument = gql`
    mutation DeleteRound($id: ID!) {
  roundDelete(id: $id) {
    success
    errors {
      ...Errors
    }
  }
}
    ${ErrorsFragmentDoc}`;
export type DeleteRoundMutationFn = Apollo.MutationFunction<DeleteRoundMutation, DeleteRoundMutationVariables>;

/**
 * __useDeleteRoundMutation__
 *
 * To run a mutation, you first call `useDeleteRoundMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteRoundMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteRoundMutation, { data, loading, error }] = useDeleteRoundMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteRoundMutation(baseOptions?: Apollo.MutationHookOptions<DeleteRoundMutation, DeleteRoundMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteRoundMutation, DeleteRoundMutationVariables>(DeleteRoundDocument, options);
      }
export type DeleteRoundMutationHookResult = ReturnType<typeof useDeleteRoundMutation>;
export type DeleteRoundMutationResult = Apollo.MutationResult<DeleteRoundMutation>;
export type DeleteRoundMutationOptions = Apollo.BaseMutationOptions<DeleteRoundMutation, DeleteRoundMutationVariables>;
export const GeneratePairingsDocument = gql`
    mutation GeneratePairings($eventId: ID!, $playerIds: [ID!]!) {
  eventGeneratePairings(eventId: $eventId, playerIds: $playerIds) {
    pairings {
      player1 {
        id
        name
      }
      player2 {
        id
        name
      }
    }
  }
}
    `;
export type GeneratePairingsMutationFn = Apollo.MutationFunction<GeneratePairingsMutation, GeneratePairingsMutationVariables>;

/**
 * __useGeneratePairingsMutation__
 *
 * To run a mutation, you first call `useGeneratePairingsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGeneratePairingsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [generatePairingsMutation, { data, loading, error }] = useGeneratePairingsMutation({
 *   variables: {
 *      eventId: // value for 'eventId'
 *      playerIds: // value for 'playerIds'
 *   },
 * });
 */
export function useGeneratePairingsMutation(baseOptions?: Apollo.MutationHookOptions<GeneratePairingsMutation, GeneratePairingsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<GeneratePairingsMutation, GeneratePairingsMutationVariables>(GeneratePairingsDocument, options);
      }
export type GeneratePairingsMutationHookResult = ReturnType<typeof useGeneratePairingsMutation>;
export type GeneratePairingsMutationResult = Apollo.MutationResult<GeneratePairingsMutation>;
export type GeneratePairingsMutationOptions = Apollo.BaseMutationOptions<GeneratePairingsMutation, GeneratePairingsMutationVariables>;
export const EventShowDocument = gql`
    query EventShow($id: ID!) {
  event(id: $id) {
    id
    name
    ...EventLayout
  }
}
    ${EventLayoutFragmentDoc}`;

/**
 * __useEventShowQuery__
 *
 * To run a query within a React component, call `useEventShowQuery` and pass it any options that fit your needs.
 * When your component renders, `useEventShowQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEventShowQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useEventShowQuery(baseOptions: Apollo.QueryHookOptions<EventShowQuery, EventShowQueryVariables> & ({ variables: EventShowQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EventShowQuery, EventShowQueryVariables>(EventShowDocument, options);
      }
export function useEventShowLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventShowQuery, EventShowQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EventShowQuery, EventShowQueryVariables>(EventShowDocument, options);
        }
export function useEventShowSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<EventShowQuery, EventShowQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<EventShowQuery, EventShowQueryVariables>(EventShowDocument, options);
        }
export type EventShowQueryHookResult = ReturnType<typeof useEventShowQuery>;
export type EventShowLazyQueryHookResult = ReturnType<typeof useEventShowLazyQuery>;
export type EventShowSuspenseQueryHookResult = ReturnType<typeof useEventShowSuspenseQuery>;
export type EventShowQueryResult = Apollo.QueryResult<EventShowQuery, EventShowQueryVariables>;
export const EventExportDocument = gql`
    query EventExport($id: ID!) {
  event(id: $id) {
    id
    ...EventLayout
    players(orderBy: SCORE, orderByDirection: DESC) {
      nodes {
        id
        name
        score
        winsCount
        lossesCount
        drawsCount
        opponentWinRate
      }
    }
    rounds(orderBy: NUMBER, orderByDirection: DESC) {
      id
      number
      matches {
        id
        table
        player1 {
          id
          name
          winsCount
          lossesCount
          drawsCount
        }
        player2 {
          id
          name
          winsCount
          lossesCount
          drawsCount
        }
      }
    }
  }
}
    ${EventLayoutFragmentDoc}`;

/**
 * __useEventExportQuery__
 *
 * To run a query within a React component, call `useEventExportQuery` and pass it any options that fit your needs.
 * When your component renders, `useEventExportQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEventExportQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useEventExportQuery(baseOptions: Apollo.QueryHookOptions<EventExportQuery, EventExportQueryVariables> & ({ variables: EventExportQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EventExportQuery, EventExportQueryVariables>(EventExportDocument, options);
      }
export function useEventExportLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventExportQuery, EventExportQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EventExportQuery, EventExportQueryVariables>(EventExportDocument, options);
        }
export function useEventExportSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<EventExportQuery, EventExportQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<EventExportQuery, EventExportQueryVariables>(EventExportDocument, options);
        }
export type EventExportQueryHookResult = ReturnType<typeof useEventExportQuery>;
export type EventExportLazyQueryHookResult = ReturnType<typeof useEventExportLazyQuery>;
export type EventExportSuspenseQueryHookResult = ReturnType<typeof useEventExportSuspenseQuery>;
export type EventExportQueryResult = Apollo.QueryResult<EventExportQuery, EventExportQueryVariables>;
export const EventMatchesDocument = gql`
    query EventMatches($id: ID!, $deleted: DeletedFilter) {
  event(id: $id) {
    id
    name
    ...EventLayout
    ...CreateRoundButton
    rounds(deleted: $deleted, orderBy: NUMBER, orderByDirection: DESC) {
      ...RoundListItem
      ...Round
    }
    players {
      totalCount
    }
  }
}
    ${EventLayoutFragmentDoc}
${CreateRoundButtonFragmentDoc}
${RoundListItemFragmentDoc}
${RoundFragmentDoc}`;

/**
 * __useEventMatchesQuery__
 *
 * To run a query within a React component, call `useEventMatchesQuery` and pass it any options that fit your needs.
 * When your component renders, `useEventMatchesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEventMatchesQuery({
 *   variables: {
 *      id: // value for 'id'
 *      deleted: // value for 'deleted'
 *   },
 * });
 */
export function useEventMatchesQuery(baseOptions: Apollo.QueryHookOptions<EventMatchesQuery, EventMatchesQueryVariables> & ({ variables: EventMatchesQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EventMatchesQuery, EventMatchesQueryVariables>(EventMatchesDocument, options);
      }
export function useEventMatchesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventMatchesQuery, EventMatchesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EventMatchesQuery, EventMatchesQueryVariables>(EventMatchesDocument, options);
        }
export function useEventMatchesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<EventMatchesQuery, EventMatchesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<EventMatchesQuery, EventMatchesQueryVariables>(EventMatchesDocument, options);
        }
export type EventMatchesQueryHookResult = ReturnType<typeof useEventMatchesQuery>;
export type EventMatchesLazyQueryHookResult = ReturnType<typeof useEventMatchesLazyQuery>;
export type EventMatchesSuspenseQueryHookResult = ReturnType<typeof useEventMatchesSuspenseQuery>;
export type EventMatchesQueryResult = Apollo.QueryResult<EventMatchesQuery, EventMatchesQueryVariables>;
export const SetMatchResolutionDocument = gql`
    mutation SetMatchResolution($id: ID!, $winnerId: ID, $draw: Boolean!) {
  matchUpdate(id: $id, input: {winnerId: $winnerId, draw: $draw}) {
    match {
      id
      winnerId
      draw
      round {
        id
        isComplete
      }
    }
    errors {
      ...Errors
    }
  }
}
    ${ErrorsFragmentDoc}`;
export type SetMatchResolutionMutationFn = Apollo.MutationFunction<SetMatchResolutionMutation, SetMatchResolutionMutationVariables>;

/**
 * __useSetMatchResolutionMutation__
 *
 * To run a mutation, you first call `useSetMatchResolutionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetMatchResolutionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setMatchResolutionMutation, { data, loading, error }] = useSetMatchResolutionMutation({
 *   variables: {
 *      id: // value for 'id'
 *      winnerId: // value for 'winnerId'
 *      draw: // value for 'draw'
 *   },
 * });
 */
export function useSetMatchResolutionMutation(baseOptions?: Apollo.MutationHookOptions<SetMatchResolutionMutation, SetMatchResolutionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SetMatchResolutionMutation, SetMatchResolutionMutationVariables>(SetMatchResolutionDocument, options);
      }
export type SetMatchResolutionMutationHookResult = ReturnType<typeof useSetMatchResolutionMutation>;
export type SetMatchResolutionMutationResult = Apollo.MutationResult<SetMatchResolutionMutation>;
export type SetMatchResolutionMutationOptions = Apollo.BaseMutationOptions<SetMatchResolutionMutation, SetMatchResolutionMutationVariables>;
export const EventPlayersDocument = gql`
    query EventPlayers($id: ID!, $deleted: DeletedFilter) {
  event(id: $id) {
    id
    name
    ...EventLayout
    ...CreatePlayerButton
    ...ImportPlayersButton
    players(deleted: $deleted) {
      nodes {
        ...PlayerTable
      }
    }
  }
}
    ${EventLayoutFragmentDoc}
${CreatePlayerButtonFragmentDoc}
${ImportPlayersButtonFragmentDoc}
${PlayerTableFragmentDoc}`;

/**
 * __useEventPlayersQuery__
 *
 * To run a query within a React component, call `useEventPlayersQuery` and pass it any options that fit your needs.
 * When your component renders, `useEventPlayersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEventPlayersQuery({
 *   variables: {
 *      id: // value for 'id'
 *      deleted: // value for 'deleted'
 *   },
 * });
 */
export function useEventPlayersQuery(baseOptions: Apollo.QueryHookOptions<EventPlayersQuery, EventPlayersQueryVariables> & ({ variables: EventPlayersQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EventPlayersQuery, EventPlayersQueryVariables>(EventPlayersDocument, options);
      }
export function useEventPlayersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventPlayersQuery, EventPlayersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EventPlayersQuery, EventPlayersQueryVariables>(EventPlayersDocument, options);
        }
export function useEventPlayersSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<EventPlayersQuery, EventPlayersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<EventPlayersQuery, EventPlayersQueryVariables>(EventPlayersDocument, options);
        }
export type EventPlayersQueryHookResult = ReturnType<typeof useEventPlayersQuery>;
export type EventPlayersLazyQueryHookResult = ReturnType<typeof useEventPlayersLazyQuery>;
export type EventPlayersSuspenseQueryHookResult = ReturnType<typeof useEventPlayersSuspenseQuery>;
export type EventPlayersQueryResult = Apollo.QueryResult<EventPlayersQuery, EventPlayersQueryVariables>;
export const EventSlipsDocument = gql`
    query EventSlips($id: ID!) {
  event(id: $id) {
    id
    name
    ...EventLayout
    ...SlipEvent
    rounds(orderBy: NUMBER, orderByDirection: DESC) {
      id
      ...SlipRound
      matches {
        ...SlipMatch
      }
    }
  }
}
    ${EventLayoutFragmentDoc}
${SlipEventFragmentDoc}
${SlipRoundFragmentDoc}
${SlipMatchFragmentDoc}`;

/**
 * __useEventSlipsQuery__
 *
 * To run a query within a React component, call `useEventSlipsQuery` and pass it any options that fit your needs.
 * When your component renders, `useEventSlipsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEventSlipsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useEventSlipsQuery(baseOptions: Apollo.QueryHookOptions<EventSlipsQuery, EventSlipsQueryVariables> & ({ variables: EventSlipsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EventSlipsQuery, EventSlipsQueryVariables>(EventSlipsDocument, options);
      }
export function useEventSlipsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventSlipsQuery, EventSlipsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EventSlipsQuery, EventSlipsQueryVariables>(EventSlipsDocument, options);
        }
export function useEventSlipsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<EventSlipsQuery, EventSlipsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<EventSlipsQuery, EventSlipsQueryVariables>(EventSlipsDocument, options);
        }
export type EventSlipsQueryHookResult = ReturnType<typeof useEventSlipsQuery>;
export type EventSlipsLazyQueryHookResult = ReturnType<typeof useEventSlipsLazyQuery>;
export type EventSlipsSuspenseQueryHookResult = ReturnType<typeof useEventSlipsSuspenseQuery>;
export type EventSlipsQueryResult = Apollo.QueryResult<EventSlipsQuery, EventSlipsQueryVariables>;
export const EventTimersDocument = gql`
    query EventTimers($id: ID!) {
  event(id: $id) {
    id
    name
    ...EventLayout
    timers {
      ...Timer
    }
  }
  timerPresets {
    nodes {
      ...TimerPresetSelect
    }
  }
}
    ${EventLayoutFragmentDoc}
${TimerFragmentDoc}
${TimerPresetSelectFragmentDoc}`;

/**
 * __useEventTimersQuery__
 *
 * To run a query within a React component, call `useEventTimersQuery` and pass it any options that fit your needs.
 * When your component renders, `useEventTimersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEventTimersQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useEventTimersQuery(baseOptions: Apollo.QueryHookOptions<EventTimersQuery, EventTimersQueryVariables> & ({ variables: EventTimersQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EventTimersQuery, EventTimersQueryVariables>(EventTimersDocument, options);
      }
export function useEventTimersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventTimersQuery, EventTimersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EventTimersQuery, EventTimersQueryVariables>(EventTimersDocument, options);
        }
export function useEventTimersSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<EventTimersQuery, EventTimersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<EventTimersQuery, EventTimersQueryVariables>(EventTimersDocument, options);
        }
export type EventTimersQueryHookResult = ReturnType<typeof useEventTimersQuery>;
export type EventTimersLazyQueryHookResult = ReturnType<typeof useEventTimersLazyQuery>;
export type EventTimersSuspenseQueryHookResult = ReturnType<typeof useEventTimersSuspenseQuery>;
export type EventTimersQueryResult = Apollo.QueryResult<EventTimersQuery, EventTimersQueryVariables>;
export const TimerEventDocument = gql`
    subscription TimerEvent($eventId: ID!) {
  timerEvent(eventId: $eventId) {
    eventType
    timer {
      ...Timer
    }
  }
}
    ${TimerFragmentDoc}`;

/**
 * __useTimerEventSubscription__
 *
 * To run a query within a React component, call `useTimerEventSubscription` and pass it any options that fit your needs.
 * When your component renders, `useTimerEventSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTimerEventSubscription({
 *   variables: {
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useTimerEventSubscription(baseOptions: Apollo.SubscriptionHookOptions<TimerEventSubscription, TimerEventSubscriptionVariables> & ({ variables: TimerEventSubscriptionVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<TimerEventSubscription, TimerEventSubscriptionVariables>(TimerEventDocument, options);
      }
export type TimerEventSubscriptionHookResult = ReturnType<typeof useTimerEventSubscription>;
export type TimerEventSubscriptionResult = Apollo.SubscriptionResult<TimerEventSubscription>;
export const TimerDeletedDocument = gql`
    subscription TimerDeleted($eventId: ID!) {
  timerDeleted(eventId: $eventId) {
    timerId
  }
}
    `;

/**
 * __useTimerDeletedSubscription__
 *
 * To run a query within a React component, call `useTimerDeletedSubscription` and pass it any options that fit your needs.
 * When your component renders, `useTimerDeletedSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTimerDeletedSubscription({
 *   variables: {
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useTimerDeletedSubscription(baseOptions: Apollo.SubscriptionHookOptions<TimerDeletedSubscription, TimerDeletedSubscriptionVariables> & ({ variables: TimerDeletedSubscriptionVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<TimerDeletedSubscription, TimerDeletedSubscriptionVariables>(TimerDeletedDocument, options);
      }
export type TimerDeletedSubscriptionHookResult = ReturnType<typeof useTimerDeletedSubscription>;
export type TimerDeletedSubscriptionResult = Apollo.SubscriptionResult<TimerDeletedSubscription>;
export const CreateTimerDocument = gql`
    mutation CreateTimer($eventId: ID!, $input: TimerCreateInput!) {
  timerCreate(eventId: $eventId, input: $input) {
    timer {
      ...Timer
    }
  }
}
    ${TimerFragmentDoc}`;
export type CreateTimerMutationFn = Apollo.MutationFunction<CreateTimerMutation, CreateTimerMutationVariables>;

/**
 * __useCreateTimerMutation__
 *
 * To run a mutation, you first call `useCreateTimerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateTimerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createTimerMutation, { data, loading, error }] = useCreateTimerMutation({
 *   variables: {
 *      eventId: // value for 'eventId'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateTimerMutation(baseOptions?: Apollo.MutationHookOptions<CreateTimerMutation, CreateTimerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateTimerMutation, CreateTimerMutationVariables>(CreateTimerDocument, options);
      }
export type CreateTimerMutationHookResult = ReturnType<typeof useCreateTimerMutation>;
export type CreateTimerMutationResult = Apollo.MutationResult<CreateTimerMutation>;
export type CreateTimerMutationOptions = Apollo.BaseMutationOptions<CreateTimerMutation, CreateTimerMutationVariables>;
export const UpdateTimerDocument = gql`
    mutation UpdateTimer($id: ID!, $input: TimerUpdateInput!) {
  timerUpdate(id: $id, input: $input) {
    timer {
      ...Timer
    }
  }
}
    ${TimerFragmentDoc}`;
export type UpdateTimerMutationFn = Apollo.MutationFunction<UpdateTimerMutation, UpdateTimerMutationVariables>;

/**
 * __useUpdateTimerMutation__
 *
 * To run a mutation, you first call `useUpdateTimerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateTimerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateTimerMutation, { data, loading, error }] = useUpdateTimerMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateTimerMutation(baseOptions?: Apollo.MutationHookOptions<UpdateTimerMutation, UpdateTimerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateTimerMutation, UpdateTimerMutationVariables>(UpdateTimerDocument, options);
      }
export type UpdateTimerMutationHookResult = ReturnType<typeof useUpdateTimerMutation>;
export type UpdateTimerMutationResult = Apollo.MutationResult<UpdateTimerMutation>;
export type UpdateTimerMutationOptions = Apollo.BaseMutationOptions<UpdateTimerMutation, UpdateTimerMutationVariables>;
export const DeleteTimerDocument = gql`
    mutation DeleteTimer($id: ID!) {
  timerDelete(id: $id) {
    success
  }
}
    `;
export type DeleteTimerMutationFn = Apollo.MutationFunction<DeleteTimerMutation, DeleteTimerMutationVariables>;

/**
 * __useDeleteTimerMutation__
 *
 * To run a mutation, you first call `useDeleteTimerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteTimerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteTimerMutation, { data, loading, error }] = useDeleteTimerMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteTimerMutation(baseOptions?: Apollo.MutationHookOptions<DeleteTimerMutation, DeleteTimerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteTimerMutation, DeleteTimerMutationVariables>(DeleteTimerDocument, options);
      }
export type DeleteTimerMutationHookResult = ReturnType<typeof useDeleteTimerMutation>;
export type DeleteTimerMutationResult = Apollo.MutationResult<DeleteTimerMutation>;
export type DeleteTimerMutationOptions = Apollo.BaseMutationOptions<DeleteTimerMutation, DeleteTimerMutationVariables>;
export const PauseTimerDocument = gql`
    mutation PauseTimer($id: ID!) {
  timerPause(id: $id) {
    timer {
      ...Timer
    }
  }
}
    ${TimerFragmentDoc}`;
export type PauseTimerMutationFn = Apollo.MutationFunction<PauseTimerMutation, PauseTimerMutationVariables>;

/**
 * __usePauseTimerMutation__
 *
 * To run a mutation, you first call `usePauseTimerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePauseTimerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [pauseTimerMutation, { data, loading, error }] = usePauseTimerMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePauseTimerMutation(baseOptions?: Apollo.MutationHookOptions<PauseTimerMutation, PauseTimerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PauseTimerMutation, PauseTimerMutationVariables>(PauseTimerDocument, options);
      }
export type PauseTimerMutationHookResult = ReturnType<typeof usePauseTimerMutation>;
export type PauseTimerMutationResult = Apollo.MutationResult<PauseTimerMutation>;
export type PauseTimerMutationOptions = Apollo.BaseMutationOptions<PauseTimerMutation, PauseTimerMutationVariables>;
export const UnpauseTimerDocument = gql`
    mutation UnpauseTimer($id: ID!) {
  timerUnpause(id: $id) {
    timer {
      ...Timer
    }
  }
}
    ${TimerFragmentDoc}`;
export type UnpauseTimerMutationFn = Apollo.MutationFunction<UnpauseTimerMutation, UnpauseTimerMutationVariables>;

/**
 * __useUnpauseTimerMutation__
 *
 * To run a mutation, you first call `useUnpauseTimerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUnpauseTimerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [unpauseTimerMutation, { data, loading, error }] = useUnpauseTimerMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useUnpauseTimerMutation(baseOptions?: Apollo.MutationHookOptions<UnpauseTimerMutation, UnpauseTimerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UnpauseTimerMutation, UnpauseTimerMutationVariables>(UnpauseTimerDocument, options);
      }
export type UnpauseTimerMutationHookResult = ReturnType<typeof useUnpauseTimerMutation>;
export type UnpauseTimerMutationResult = Apollo.MutationResult<UnpauseTimerMutation>;
export type UnpauseTimerMutationOptions = Apollo.BaseMutationOptions<UnpauseTimerMutation, UnpauseTimerMutationVariables>;
export const SkipTimerToNextPhaseDocument = gql`
    mutation SkipTimerToNextPhase($id: ID!) {
  timerSkipToNextPhase(id: $id) {
    timer {
      ...Timer
    }
  }
}
    ${TimerFragmentDoc}`;
export type SkipTimerToNextPhaseMutationFn = Apollo.MutationFunction<SkipTimerToNextPhaseMutation, SkipTimerToNextPhaseMutationVariables>;

/**
 * __useSkipTimerToNextPhaseMutation__
 *
 * To run a mutation, you first call `useSkipTimerToNextPhaseMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSkipTimerToNextPhaseMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [skipTimerToNextPhaseMutation, { data, loading, error }] = useSkipTimerToNextPhaseMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useSkipTimerToNextPhaseMutation(baseOptions?: Apollo.MutationHookOptions<SkipTimerToNextPhaseMutation, SkipTimerToNextPhaseMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SkipTimerToNextPhaseMutation, SkipTimerToNextPhaseMutationVariables>(SkipTimerToNextPhaseDocument, options);
      }
export type SkipTimerToNextPhaseMutationHookResult = ReturnType<typeof useSkipTimerToNextPhaseMutation>;
export type SkipTimerToNextPhaseMutationResult = Apollo.MutationResult<SkipTimerToNextPhaseMutation>;
export type SkipTimerToNextPhaseMutationOptions = Apollo.BaseMutationOptions<SkipTimerToNextPhaseMutation, SkipTimerToNextPhaseMutationVariables>;
export const CloneTimerWithOffsetDocument = gql`
    mutation CloneTimerWithOffset($id: ID!, $input: TimerCloneWithOffsetInput!) {
  timerCloneWithOffset(id: $id, input: $input) {
    timer {
      ...Timer
    }
  }
}
    ${TimerFragmentDoc}`;
export type CloneTimerWithOffsetMutationFn = Apollo.MutationFunction<CloneTimerWithOffsetMutation, CloneTimerWithOffsetMutationVariables>;

/**
 * __useCloneTimerWithOffsetMutation__
 *
 * To run a mutation, you first call `useCloneTimerWithOffsetMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCloneTimerWithOffsetMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [cloneTimerWithOffsetMutation, { data, loading, error }] = useCloneTimerWithOffsetMutation({
 *   variables: {
 *      id: // value for 'id'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCloneTimerWithOffsetMutation(baseOptions?: Apollo.MutationHookOptions<CloneTimerWithOffsetMutation, CloneTimerWithOffsetMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CloneTimerWithOffsetMutation, CloneTimerWithOffsetMutationVariables>(CloneTimerWithOffsetDocument, options);
      }
export type CloneTimerWithOffsetMutationHookResult = ReturnType<typeof useCloneTimerWithOffsetMutation>;
export type CloneTimerWithOffsetMutationResult = Apollo.MutationResult<CloneTimerWithOffsetMutation>;
export type CloneTimerWithOffsetMutationOptions = Apollo.BaseMutationOptions<CloneTimerWithOffsetMutation, CloneTimerWithOffsetMutationVariables>;
export const ResetTimerDocument = gql`
    mutation ResetTimer($id: ID!) {
  timerReset(id: $id) {
    timer {
      ...Timer
    }
  }
}
    ${TimerFragmentDoc}`;
export type ResetTimerMutationFn = Apollo.MutationFunction<ResetTimerMutation, ResetTimerMutationVariables>;

/**
 * __useResetTimerMutation__
 *
 * To run a mutation, you first call `useResetTimerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useResetTimerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [resetTimerMutation, { data, loading, error }] = useResetTimerMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useResetTimerMutation(baseOptions?: Apollo.MutationHookOptions<ResetTimerMutation, ResetTimerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ResetTimerMutation, ResetTimerMutationVariables>(ResetTimerDocument, options);
      }
export type ResetTimerMutationHookResult = ReturnType<typeof useResetTimerMutation>;
export type ResetTimerMutationResult = Apollo.MutationResult<ResetTimerMutation>;
export type ResetTimerMutationOptions = Apollo.BaseMutationOptions<ResetTimerMutation, ResetTimerMutationVariables>;
export const EventsIndexDocument = gql`
    query EventsIndex($deleted: DeletedFilter) {
  events(deleted: $deleted) {
    ...EventList
  }
}
    ${EventListFragmentDoc}`;

/**
 * __useEventsIndexQuery__
 *
 * To run a query within a React component, call `useEventsIndexQuery` and pass it any options that fit your needs.
 * When your component renders, `useEventsIndexQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEventsIndexQuery({
 *   variables: {
 *      deleted: // value for 'deleted'
 *   },
 * });
 */
export function useEventsIndexQuery(baseOptions?: Apollo.QueryHookOptions<EventsIndexQuery, EventsIndexQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EventsIndexQuery, EventsIndexQueryVariables>(EventsIndexDocument, options);
      }
export function useEventsIndexLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventsIndexQuery, EventsIndexQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EventsIndexQuery, EventsIndexQueryVariables>(EventsIndexDocument, options);
        }
export function useEventsIndexSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<EventsIndexQuery, EventsIndexQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<EventsIndexQuery, EventsIndexQueryVariables>(EventsIndexDocument, options);
        }
export type EventsIndexQueryHookResult = ReturnType<typeof useEventsIndexQuery>;
export type EventsIndexLazyQueryHookResult = ReturnType<typeof useEventsIndexLazyQuery>;
export type EventsIndexSuspenseQueryHookResult = ReturnType<typeof useEventsIndexSuspenseQuery>;
export type EventsIndexQueryResult = Apollo.QueryResult<EventsIndexQuery, EventsIndexQueryVariables>;

      export interface PossibleTypesResultData {
        possibleTypes: {
          [key: string]: string[]
        }
      }
      const result: PossibleTypesResultData = {
  "possibleTypes": {}
};
      export default result;
    